[{"id":0,"href":"/docs/actions-and-protocols/","title":"Communication and Protocols","parent":"Docs","content":" Actions ComputedBoundsAction RequestBoundsAction RequestModelAction SetModelAction UpdateModelAction Protocols 1. No Layout Computation / Server-Only Layout 2. Client-Only Layout 3. Client and Server Layout Sprotty uses actions to communicate between ModelSource and ActionDispatcher regardless if the model source is local or remote. The core of this communication follows specific protocols. This Chapter will give an overview of these protocols and their used actions.\nActions Actions are plain JSON serializable objects so that they can easily be passed through all kinds of APIs. They can be distinguished through their KIND string property. In this section, the most important actions for understanding the basic communication protocols are described. For more info on existing actions see actions.ts\nComputedBoundsAction Sent from the client to the model source to transmit the result of bounds computation for micro-layout. This is sent as a response to a RequestBoundsAction\nRequestBoundsAction Sent from the model source to the client to request bounds for the given model. This triggers the micro-layout computation.\nRequestModelAction Sent from client to model source to request a new model. Usually, this is the first action sent to initiate the communication. Optionally this can contain an options object containing configuration for the DiagramServer, like properties for needsClientLayout and needsServerLayout.\nSetModelAction Sent from the model source to the client to set the model. It contains the schema for the new graph. Should a model already exist in the client, it is overwritten.\nUpdateModelAction Sent from model source to client to update the current model. Allows animating the transition from the old to the new model and contains properties for the transition.\nProtocols Based on where layouting should be done there are 3 different protocols through which the DiagramServer and client can communicate. On the client-side, this can be configured through the configureViewerOptions in the dependency injection container.\nconfigureViewerOptions(context, { needsClientLayout: false, needServerLayout: true, baseDiv: containerId }); On the server-side layout options need to be set in the DiagramServer\ndiagramServer.setNeedsClientLayout(false); diagramServer.setNeedsServerLayout(true); 1. No Layout Computation / Server-Only Layout In this scenario, the server needs to provide a model with complete layout information, so that no further processing by the client is required. sequenceDiagram participant C as Client participant S as Server Note over C,S: Client requests model C-\u003e\u003eS: RequestModelAction S-\u003e\u003eC: SetModelAction Note over C,S: Server updates model loop when model changes S-\u003e\u003eC: UpdateModelAction end First the client requests and receives the model from the server. After that, the server can update the model whenever necessary.\n2. Client-Only Layout The server sends RequestBoundsAction (highlighted in yellow) to the client instead of updating the model directly. The client does not forward the resulting ComputedBoundsAction to the server because that would be an unnecessary round-trip. The updated bounds are applied locally in the client instead. sequenceDiagram participant C as Client participant S as Server Note over C,S: Client requests model C-\u003e\u003eS: RequestModelAction rect rgb(240, 240, 180, .4) S-\u003e\u003eC: RequestBoundsAction end Note over C,S: Server updates model loop when model changes rect rgb(240, 240, 180, .4) S-\u003e\u003eC: RequestBoundsAction end end This is very similar to scenario 1 (with server-only layout). However, instead of SetModelAction and UpdateModelAction we use the RequestBoundsAction which contains the full graph\n3. Client and Server Layout This is similar to the second scenario above, but here the ComputedBoundsAction is processed on the server so it can apply its own layout engine to the updated model. sequenceDiagram participant C as Client participant S as Server Note over C,S: Client requests model C -\u003e\u003e S: RequestModelAction S -\u003e\u003e C: RequestBoundsAction C -\u003e\u003e S: ComputedBoundsAction S -\u003e\u003e C: UpdateModelAction Note over C,S: Server updates model loop when model changes S -\u003e\u003e C: RequestBoundsAction C -\u003e\u003e S: ComputedBoundsAction S -\u003e\u003e C: UpdateModelAction end ","description":"Actions ComputedBoundsAction RequestBoundsAction RequestModelAction SetModelAction UpdateModelAction Protocols 1. No Layout Computation / Server-Only Layout 2. Client-Only Layout 3. Client and Server Layout Sprotty uses actions to communicate between ModelSource and ActionDispatcher regardless if the model source is local or remote. The core of this communication follows specific protocols. This Chapter will give an overview of these protocols and their used actions.\nActions Actions are plain JSON serializable objects so that they can easily be passed through all kinds of APIs."},{"id":1,"href":"/docs/custom-interactions/","title":"Creating Custom Interaction","parent":"Docs","content":" Buttons and Button Handlers Mouse and Keyboard Listeners Projection Bars Buttons and Button Handlers Buttons in Sprotty work similarly to the other model elements, but they enable you to directly hook up handlers that react to the push of a button. As in the other examples with other types of nodes, we first need to define the model and view class and define its type ID. in addition, we also need to define a button handler of type IButtonHandler.\nconst container = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { const context = { bind, unbind, isBound, rebind }; configureModelElement(context, \u0026#39;graph\u0026#39;, SGraph, SGraphView); configureModelElement(context, \u0026#39;button:custom\u0026#39;, SButton, CustomButtonView); configureButtonHandler({bind, isBound}, \u0026#39;button:custom\u0026#39;, CustomButtonHandler); configureViewerOptions(context, { needsClientLayout: true, baseDiv: \u0026#39;sprotty\u0026#39; }); }); A button handler is a simple injectable class with a buttonPressed(button: SButton): Action[] method. The actions that this method returns are passed to the ActionDispatcher to be handled there.\n@injectable() export class CustomButtonHandler implements IButtonHandler { buttonPressed(button: SButton): Action[] { alert(\u0026#39;button on\u0026#39; + button.parent.id + \u0026#39; pressed\u0026#39;); return []; } } Mouse and Keyboard Listeners Sprotty also offers the ability to attach mouse and keyboard listeners by registering MouseListener or KeyListener. This can be simply done by binding the custom listener to the respective listener type in your DI-container like this:\nbind(CustomMouseListener).toSelf().inSingletonScope(); bind(TYPES.MouseListener).toService(CustomMouseListener); These listeners are global, meaning they react to every interaction with the diagram. A very simple mouse Listener would look like this:\nexport class CustomMouseListener extends MouseListener { doubleClick(target: SModelElementImpl, event: MouseEvent): (Action | Promise\u0026lt;Action\u0026gt;)[] { alert(\u0026#39;double clicked \u0026#39; + target.id) return []; } } If only specific types of nodes are supposed to be interacted with through this custom listener, it\u0026rsquo;s recommended to create a custom feature.\nProjection Bars Another interactive Sprotty feature is the ProjectedViewportView. This view automatically adds a vertical and horizontal scrollbar to our diagram view in which our current viewport is shown, like in the following image.\nTo activate this feature, instead of using SGraphImpl and SGraphView for our root element, as we did in the other examples, we use ViewportRootElement and ProjectedViewportView. The scrollbars created through ProjectedViewportView can be styled via the .sprotty-viewport and .sprotty-projection-bar CSS classes.\nAs we can see in the image, these scrollbars can contain projections of our nodes, which show their horizontal and vertical position. Double-clicking on a projection will center the view on the node the projection belongs to.\nTo add projections we add the Projectable type to the nodes in our model schema like this:\n\u0026lt;SNode \u0026amp; Projectable\u0026gt;{ id: \u0026#39;svg\u0026#39;, type: \u0026#39;node:svg\u0026#39;, text: \u0026#39;\u0026#39;, projectionCssClasses: [\u0026#39;svg-projection\u0026#39;] } The Projectable interface requires us to specify the projectionCssClasses property, which defines the CSS classes the framework will apply to the HTML div element that represents the projection in the projection bar. If no projectionCssClasses property value is specified, no projection will be created. As projections are simple HTML div elements positioned on the projection bar, they can easily be styled as follows:\n.svg-projection { background-color: rgba(255, 153, 0, 0.5); } ","description":"Buttons and Button Handlers Mouse and Keyboard Listeners Projection Bars Buttons and Button Handlers Buttons in Sprotty work similarly to the other model elements, but they enable you to directly hook up handlers that react to the push of a button. As in the other examples with other types of nodes, we first need to define the model and view class and define its type ID. in addition, we also need to define a button handler of type IButtonHandler."},{"id":2,"href":"/docs/","title":"Docs","parent":"Sprotty","content":"","description":""},{"id":3,"href":"/docs/features/","title":"Features","parent":"Docs","content":" alignFeature boundsFeature connectableFeature creatingOnDragFeature decorationFeature deletableFeature edgeLayoutFeature editFeature editLabelFeature expandFeature exportFeature fadeFeature hoverFeedbackFeature layoutableChildFeature layoutContainerFeature moveFeature nameFeature openFeature popupFeature selectFeature viewportFeature withEditLabelFeature Features can be viewed as a set of functionalities that a given element can support. They can enrich the behavior and usability of the diagram model.\nSModelElements can have default features that will apply to all model elements that are instance of this SModelElement.Default features are specified in the DEFAULT_FEATURES field, which can be overridden in inherited classes. This way, the default features will be enabled for all instances of the class.\nLet\u0026rsquo;s have a look at the SNodeImpl class and how it implements default features:\nexport class SNodeImpl extends SConnectableElementImpl implements Selectable, Fadeable, Hoverable { static readonly DEFAULT_FEATURES = [connectableFeature, deletableFeature, selectFeature, boundsFeature, moveFeature, layoutContainerFeature, fadeFeature, hoverFeedbackFeature, popupFeature]; ... } It is possible to fine-tune the behavior in the dependency injection container by enabling or disabling features for a given model element type.\nconfigureElement(\u0026#39;my-node-type\u0026#39;, SNodeImpl, RectangularNodeView, {enable: [layoutableChildFeature], disable: [moveFeature]}) To ensure that the required additional properties are present on the model element, Sprotty comes with a set of interfaces to ensure correct implementation in the model element class. These interfaces must extend SModelExtension.\nalignFeature Controls the position adjustment of an element. It is given by the alignment: Point property of an element. It applies a translate to the svg element. This translation is applied in addition to the translation that may be applied by the layout engine.\nInterface: Alignable\nexport interface Alignable extends SModelExtension { alignment: Point } boundsFeature Controls if the bounds of an element can be calculated and updated. The element needs a position and size.\nInterface: BoundsAware\nexport interface BoundsAware extends SModelExtension{ bounds: Bounds } connectableFeature Controls if an element can be connected to other elements. To be connectable, the element must be an SRoutableElementImpl and have a role of source or target.\nInterface: Connectable\nexport interface Connectable extends SModelExtension{ canConnect(routable: SRoutableElementImpl, role: \u0026#39;source\u0026#39; | \u0026#39;target\u0026#39;): boolean } creatingOnDragFeature Controls if an element is created on drag. The element needs to implement a createAction method that returns an Action that creates the element.\nInterface: CreatingOnDrag\nexport interface CreatingOnDrag extends SModelExtension { createAction(id: string): Action } decorationFeature Controls if an element is a decoration. It is generally used to show error or warning markers on model elements.\nInterface: Decoration\nexport interface Decoration extends SModelExtension {} deletableFeature Controls if an element can be deleted from the diagram. To be deletable, an element needs to be an SChildElementImpl.\nInterface: Deletable\nexport interface Deletable extends SModelExtension {} edgeLayoutFeature Controls if an element is layoutable on an edge. The element must be an SChildElementImpl, its parent must be an SRoutableElementImpl, the element must have the edgePlacement property, and must have the boundsFeature. This is commonly used for labels that are displayed on an edge.\nedgePlacement: { position: number, // between 0 and 1, from the source (0) to the target (1) side: \u0026#39;bottom\u0026#39; | \u0026#39;top\u0026#39; | \u0026#39;left\u0026#39; | \u0026#39;right\u0026#39; | \u0026#39;on\u0026#39;, rotate: boolean, offset: number, moveMode: \u0026#39;edge\u0026#39; | \u0026#39;free\u0026#39; | \u0026#39;none\u0026#39; } Interface: EdgeLayoutable\nexport interface EdgeLayoutable extends SModelExtension { edgePlacement: EdgePlacement } editFeature Controls if an edge routing can be edited. The edge must be an SRoutableElementImpl.\neditLabelFeature Controls if a label can be edited. The label must have the text property.\nInterface: EditableLabel\nexport interface EditableLabel extends SModelExtension { text: string readonly isMultiline?: boolean readonly editControlDimension?: Dimension readonly editControlPositionCorrection?: Point } expandFeature Controls if an element can be expanded. The element must have the property expanded.\nInterface: Expandable\nexport interface Expandable extends SModelExtension { expanded: boolean } exportFeature Controls if an element can be exported. It is enabled by default to the ViewportRootElement making the entire diagram exportable.\nfadeFeature Controls if an element can change its opacity. The element must have the opacity property.\nInterface: Fadeable\nexport interface Fadeable extends SModelExtension { opacity: number } hoverFeedbackFeature Controls if the element can show hover feedback. The element must have the hoverFeedback property.\nInterface: Hoverable\nexport interface Hoverable extends SModelExtension { hoverFeedback: boolean } layoutableChildFeature Controls if an element obeys its parent\u0026rsquo;s layout options. The element must use the boundsFeature.\nInterface: LayoutableChild\nexport interface LayoutableChild extends SModelExtension, BoundsAware { layoutOptions?: ModelLayoutOptions } layoutContainerFeature Controls if an element can layout its children. The element must have the layout property.\nInterface: LayoutContainer\nexport interface LayoutContainer extends LayoutableChild { layout: string } moveFeature Controls if an element is moveable. The element must have the position property.\nInterface: Locateable\nexport interface Locateable extends SModelExtension { position: Point } nameFeature Controls if an element has a name. This feature is used during renaming to change the name attribute on the model element.\nInterface: Nameable\nexport interface Nameable extends SModelExtension { name: string } openFeature Controls if an element can be opened.\npopupFeature Controls if an element display a popup on hover.\nselectFeature Controls if an element can be selected. When an element is selected, its selected property is set to true.\nInterface: Selectable\nexport interface Selectable extends SModelExtension { selected: boolean } viewportFeature Controls if an element is a viewport. The element must be a SModelRootImpl and have the zoom and scroll properties.\nwithEditLabelFeature Controls if an element has an editable label. The element must have the editableLabel property.\nInterface: WithEditableLabel\nexport interface WithEditableLabel extends SModelExtension { readonly editableLabel?: EditableLabel \u0026amp; SModelElementImpl; } ","description":"alignFeature boundsFeature connectableFeature creatingOnDragFeature decorationFeature deletableFeature edgeLayoutFeature editFeature editLabelFeature expandFeature exportFeature fadeFeature hoverFeedbackFeature layoutableChildFeature layoutContainerFeature moveFeature nameFeature openFeature popupFeature selectFeature viewportFeature withEditLabelFeature Features can be viewed as a set of functionalities that a given element can support. They can enrich the behavior and usability of the diagram model.\nSModelElements can have default features that will apply to all model elements that are instance of this SModelElement.Default features are specified in the DEFAULT_FEATURES field, which can be overridden in inherited classes."},{"id":4,"href":"/docs/getting-started/","title":"Getting Started","parent":"Docs","content":"Our \u0026lsquo;Getting Started\u0026rsquo; example consists of a simple application that displays a list of tasks, their status, and the relationship between them in a HTML page.\nThe main steps to integrate Sprotty into our application are as follows:\nSet-up your application. Define your model by creating sub-interfaces of SModelElement. Implement views to generate SVGs for each type of model element. Configure the diagram through dependency injection. Connect to a model source, either local or remote Fast-Forward With Yeoman If you\u0026rsquo;d like to skip the manual steps below and create a Sprotty-based project right away, you can use the Yeoman generator:\nnpm install -g yo generator-sprotty yo sprotty Answer a few questions and you\u0026rsquo;ll get a ready-to-use example project.\nSetting-up Our Application Our example application is based on TypeScript. In this application we will set up our project to be ready for receiving Sprotty.\nCreate a new directory and navigate to it\nInitialize the project by running\nnpm init -y This will create a package.json file.\nModify package.json to add a build script and necessary dependencies\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;esbuild ./index.ts --bundle --sourcemap --outfile=./out/index.js\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;esbuild\u0026#34;: \u0026#34;^0.17.8\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.9.5\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;reflect-metadata\u0026#34;: \u0026#34;^0.1.13\u0026#34;, \u0026#34;sprotty\u0026#34;: \u0026#34;^1.0.0\u0026#34; } } Install dependencies running npm i\nInitialize the TypeScript project\nnpx tsc --init This will create tsconfig.json file at the root of your project. You should overwrite this files with the following:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json.schemastore.org/tsconfig\u0026#34;, \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;ES2019\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;sourceMap\u0026#34;: true, \u0026#34;experimentalDecorators\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;react\u0026#34;, \u0026#34;types\u0026#34;: [ \u0026#34;reflect-metadata\u0026#34; ] }, \u0026#34;lib\u0026#34;: [ \u0026#34;ES2019\u0026#34;, \u0026#34;DOM\u0026#34; ] } Create a index.html file at the root of your project\n\u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;./out/index.js\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;sprotty-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; Add some default CSS styles by creating a styles.css file at the root of the project:\n.sprotty-graph { width: 100%; height: 100%; } .sprotty-edge { fill: none; stroke: black; stroke-width: 1px; } Our project is now set-up and ready for integrating Sprotty diagrams.\nDefine Your Model Sprotty comes with a set of model classes that you can reuse for your application. e.g. SNodeImpl and SEdgeImpl for graphs and SChildElementImpl for other views. However, it is often necessary to add application-specific properties to model elements, so their graphical views can be parameterized.\nWe will define a new interface for our nodes called TaskNode, extending Sprotty\u0026rsquo;s SNode interface with application-specific properties. Create a new file models.ts at the root of the project:\nimport { SNode } from \u0026#34;sprotty-protocol\u0026#34; export interface TaskNode extends SNode { name: string; isRunning: boolean; isFinished: boolean; } Implement Views A view maps a model element to its graphical representation. You can create your own views by creating a class implementing IView or extending a view already available in Sprotty.\nIn the following example we use the JSX syntax to create a SVG group with a rect and a text element. Add a new file views.tsx (note the tsx extension) at the root of the project:\n/** @jsx svg */ import { svg } from \u0026#39;sprotty/lib/lib/jsx\u0026#39;; import { injectable } from \u0026#39;inversify\u0026#39;; import { VNode } from \u0026#39;snabbdom\u0026#39;; import { IView, RenderingContext, SNode } from \u0026#39;sprotty\u0026#39;; import { TaskNode } from \u0026#39;./models\u0026#39;; @injectable() export class TaskNodeView implements IView { render(node: Readonly\u0026lt;SNode \u0026amp; TaskNode\u0026gt;, context: RenderingContext): VNode { const position = 50; return \u0026lt;g\u0026gt; \u0026lt;rect class-sprotty-node={true} class-task={true} class-running={node.isRunning} class-finished={node.isFinished} width={node.size.width} height={node.size.height} \u0026gt; \u0026lt;/rect\u0026gt; \u0026lt;text x={position} y={position + 5}\u0026gt;{node.name}\u0026lt;/text\u0026gt; \u0026lt;/g\u0026gt;; } } The SVG elements are styled with CSS using classes that are injected using the class-myClass={boolean expression} in the jsx expression. Add the following to styles.css:\n.sprotty-node.task { fill: #c0e0fc; stroke: #444; stroke-width: 1; } .sprotty-node.task.running { fill: #f00; } .sprotty-node.task.finished { fill: #0f0; } text { stroke-width: 0; stroke: #000; fill: #000; font-family: sans-serif; font-size: 10pt; text-anchor: middle; } Configure the Diagram The configuration of our Sprotty application is done via Dependency Injection using InversifyJS. We recommend defining your InversifyJS container in a file named di.config.ts at the root of the project which could look like this:\nimport { Container, ContainerModule } from \u0026#39;inversify\u0026#39;; import { configureModelElement, configureViewerOptions, loadDefaultModules, LocalModelSource, PolylineEdgeView, SEdgeImpl, SGraphImpl, SGraphView, SNodeImpl, TYPES } from \u0026#39;sprotty\u0026#39;; import { TaskNodeView } from \u0026#39;./views\u0026#39;; export const createContainer = (containerId: string) =\u0026gt; { const myModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { bind(TYPES.ModelSource).to(LocalModelSource).inSingletonScope(); const context = { bind, unbind, isBound, rebind }; configureModelElement(context, \u0026#39;graph\u0026#39;, SGraphImpl, SGraphView); configureModelElement(context, \u0026#39;task\u0026#39;, SNodeImpl, TaskNodeView); configureModelElement(context, \u0026#39;edge\u0026#39;, SEdgeImpl, PolylineEdgeView); configureViewerOptions(context, { needsClientLayout: false, baseDiv: containerId }); }); const container = new Container(); loadDefaultModules(container); container.load(myModule); return container; }; Views are registered using configureModelElement which takes a context, a type, an element class, and a view. loadDefaultModules is used to include Sprotty\u0026rsquo;s default modules, while container.load can be used to include extra modules required by our application.\nConnect to a Model Source Sprotty supports two kinds of model sources:\nLocalModelSource allows to create models directly in TypeScript or JavaScript WebSocketDiagramServer delegates to a remote source that is connected via a web socket In this example, we consider the local variant. To enable the model source, we add the following line to our module definition (see previous section):\nbind(TYPES.ModelSource).to(LocalModelSource).inSingletonScope() Afterwards you can use the LocalModelSource to initialize and update the model. For example, the following graph consists of three task nodes with a connection between the first two. Create a new file model-source.ts at the root of the project:\nimport { SGraph, SEdge, SNode } from \u0026#34;sprotty-protocol\u0026#34;; import { TaskNode } from \u0026#34;./models\u0026#34;; export const graph: SGraph = { type: \u0026#39;graph\u0026#39;, id: \u0026#39;graph\u0026#39;, children: [ \u0026lt;SNode \u0026amp; TaskNode\u0026gt;{ type: \u0026#39;task\u0026#39;, id: \u0026#39;task01\u0026#39;, name: \u0026#39;First Task\u0026#39;, isFinished: true, isRunning: false, position: { x: 0, y: 0 }, size: { width: 100, height: 100 } }, \u0026lt;SNode \u0026amp; TaskNode\u0026gt;{ type: \u0026#39;task\u0026#39;, id: \u0026#39;task02\u0026#39;, name: \u0026#39;Second Task\u0026#39;, isFinished: false, isRunning: true, position: { x: 0, y: 200 }, size: { width: 100, height: 100 } }, \u0026lt;SNode \u0026amp; TaskNode\u0026gt;{ type: \u0026#39;task\u0026#39;, id: \u0026#39;task03\u0026#39;, name: \u0026#39;Third Task\u0026#39;, isFinished: false, isRunning: false, position: { x: 150, y: 0 }, size: { width: 100, height: 100 } }, \u0026lt;SEdge\u0026gt;{ type: \u0026#39;edge\u0026#39;, id: \u0026#39;edge01\u0026#39;, sourceId: \u0026#39;task01\u0026#39;, targetId: \u0026#39;task02\u0026#39;, routerKind: \u0026#39;manhattan\u0026#39;, } ] }; Finally, we need to create the entry point of our application in an index.ts file:\nimport \u0026#34;reflect-metadata\u0026#34;; import { LocalModelSource, TYPES } from \u0026#39;sprotty\u0026#39;; import { createContainer } from \u0026#39;./di.config\u0026#39;; import { graph } from \u0026#39;./model-source\u0026#39;; export default function run() { const container = createContainer(\u0026#34;sprotty-container\u0026#34;); const modelSource = container.get\u0026lt;LocalModelSource\u0026gt;(TYPES.ModelSource); modelSource.setModel(graph); } document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; run()); That\u0026rsquo;s it! Run npm run build and open your HTML file, you should see the following diagram! There is some level of interactivity by default, try it out! Select nodes by clicking on them and move them around by dragging, adjust the zoom-level with the mouse wheel, navigate the diagram by panning via left-click and drag outside of a node. ","description":"Our \u0026lsquo;Getting Started\u0026rsquo; example consists of a simple application that displays a list of tasks, their status, and the relationship between them in a HTML page.\nThe main steps to integrate Sprotty into our application are as follows:\nSet-up your application. Define your model by creating sub-interfaces of SModelElement. Implement views to generate SVGs for each type of model element. Configure the diagram through dependency injection. Connect to a model source, either local or remote Fast-Forward With Yeoman If you\u0026rsquo;d like to skip the manual steps below and create a Sprotty-based project right away, you can use the Yeoman generator:"},{"id":5,"href":"/docs/introduction/","title":"Introduction","parent":"Docs","content":"Sprotty is a next-generation, open-source diagramming framework built with web-technologies.\nSome selected features:\nFast, scalable SVG rendering that is compatible with all modern browsers and stylable with CSS Animations built into the core Support for a distributed runtime with client and server Fast, reactive client architecture implemented in TypeScript Java or Node.js based server architecture Configuration via dependency injection Integrations with Xtext, Langium, the Language Server Protocol, VS Code and Theia Can be run as a rich-client as well as in the browser Where to start? If you are new with Sprotty, we recommend taking a look at our Getting Started section before diving further.\nWant to contribute? Visit the Sprotty repository and have a look at the contribution guidelines to take part in Sprotty\u0026rsquo;s development.\n","description":"Sprotty is a next-generation, open-source diagramming framework built with web-technologies.\nSome selected features:\nFast, scalable SVG rendering that is compatible with all modern browsers and stylable with CSS Animations built into the core Support for a distributed runtime with client and server Fast, reactive client architecture implemented in TypeScript Java or Node.js based server architecture Configuration via dependency injection Integrations with Xtext, Langium, the Language Server Protocol, VS Code and Theia Can be run as a rich-client as well as in the browser Where to start?"},{"id":6,"href":"/docs/micro-layout/","title":"Micro-layout","parent":"Docs","content":" Layout Configuration Layout Options Alignment Padding Size Using SCompartments for Complex Layouts Layouting Nested Nodes The micro-layout refers to the layout of elements inside of a node, i.e. the layout of nested labels, buttons, etc. It is not to be confused with the macro-layout which refers to the layout of the entire graph, e.g. the position of nodes.\nLayout Configuration Any model element that implements or extends the SNode or SCompartment interface has an optional property layout that specifies the general layout of its children elements. Sprotty implements three layout configurations by default:\nstack: children elements are stacked on top of each other (default layout) hbox: children elements are arranged horizontally vbox: children elements are arranged vertically The layout property aims at arranging children elements that do not have a meaning in terms of graph hierarchy (i.e. labels, buttons, \u0026hellip;). Please note that children that are instances of SNodeImpl do not respect the layout property by default (more on that later).\nFirst and foremost, the micro-layout engine needs to be activated in the inversify container. This is done by setting the needsClientLayout property to true in the inversify container configuration:\nconst module = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { const context = {bind, unbind, isBound, rebind}; ... configureViewerOptions(context, { needsClientLayout: true }) }) Let\u0026rsquo;s now have a look at the following graph containing 3 nodes with 3 label children, each with a different layout configuration:\nexport const graph: SGraph = { type: \u0026#39;graph\u0026#39;, id: \u0026#39;graph\u0026#39;, children: [ // this node is using a \u0026#39;vbox\u0026#39; layout \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node01\u0026#39;, layout: \u0026#39;vbox\u0026#39;, children: [ \u0026lt;SLabel\u0026gt; { id: \u0026#39;label01-1\u0026#39;, text: \u0026#39;I am using a\u0026#39;, type: \u0026#39;label\u0026#39;, }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label01-2\u0026#39;, text: \u0026#39;vbox\u0026#39;, type: \u0026#39;label\u0026#39;, cssClasses: [\u0026#39;layout-label\u0026#39;] }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label01-3\u0026#39;, text: \u0026#39;layout\u0026#39;, type: \u0026#39;label\u0026#39;, }, ] }, // this node is using a \u0026#39;hbox\u0026#39; layout \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node02\u0026#39;, layout: \u0026#39;hbox\u0026#39;, position: { x: 100, y: 0 }, children: [ \u0026lt;SLabel\u0026gt; { id: \u0026#39;label02-1\u0026#39;, text: \u0026#39;I am using a\u0026#39;, type: \u0026#39;label\u0026#39;, }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label02-2\u0026#39;, text: \u0026#39;hbox\u0026#39;, type: \u0026#39;label\u0026#39;, cssClasses: [\u0026#39;layout-label\u0026#39;] }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label02-3\u0026#39;, text: \u0026#39;layout\u0026#39;, type: \u0026#39;label\u0026#39;, }, ] }, // this node is using a \u0026#39;stack\u0026#39; layout \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node03\u0026#39;, layout: \u0026#39;stack\u0026#39;, position: { x: 265, y: 0 }, children: [ \u0026lt;SLabel\u0026gt; { id: \u0026#39;label03-1\u0026#39;, text: \u0026#39;I am using a\u0026#39;, type: \u0026#39;label\u0026#39;, }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label03-2\u0026#39;, text: \u0026#39;stack\u0026#39;, type: \u0026#39;label\u0026#39;, cssClasses: [\u0026#39;layout-label\u0026#39;] }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label03-3\u0026#39;, text: \u0026#39;layout\u0026#39;, type: \u0026#39;label\u0026#39;, }, ] }, ] }; This results in the following visuals:\nIf you want different layout configurations, you can implement your own micro-layout engine and inject it via Dependency Injection.\nLayout Options It is possible to fine-tune the micro-layout by using the property layoutOptions.\n\u0026lt;SNode\u0026gt; { ... layout: \u0026#39;vbox\u0026#39;, layoutOptions: { ... } } Alignment You can control how children are aligned with the following properties:\nhAlign: 'left' | 'center' | 'right' for the horizontal alignment (not available for layout hbox) vAlign: 'top' | 'center' | 'bottom' for the vertical alignment (not available for layout vbox) Padding Spacing between the container and its children is controlled by the following properties:\npaddingTop: number for the padding at the top of the container (in pixels) paddingRight: number for the padding at the right of the container (in pixels) paddingBottom: number for the padding at the bottom of the container (in pixels) paddingLeft: number for the padding at left top of the container (in pixels) paddingFactor: number to define a factor for the padding depending on the size of the container Size The micro-layout engine takes care of computing the size of a container depending on the size and position of its children. This can lead to unesthetic results, if for example the size of labels differs greatly between nodes. To deal with these issues, you can configure the following properties:\nminWidth: number to set the minimal width of a container (in pixels) minHeight: number to set the minimal height of a container (in pixels) resizeContainer: boolean to indicate if the size of a container is dependent on the size of its children The position of the children elements (given as x-y coordinates) is always relative to their parents. This means that to position a child element for example at the top left corner of its parent, you need to set its position to {x: 0, y: 0}.\nUsing SCompartments for Complex Layouts SCompartments are used to group SModelElements and apply a given layout to this group. This allows for creating complex layouts inside of a node.\nFor clarity and illustration purpose, the SCompartments in the following diagram have a red outline, but you usually would not want to display it. Sprotty comes with a SCompartmentView that creates only a g element grouping its nested element. The g element does not result in any shape and is used only for grouping purposes.\nThe following code snippet shows how to organize your model elements by including SCompartments to achieve the layout shown above:\nexport const graph: SGraph = { type: \u0026#39;graph\u0026#39;, id: \u0026#39;graph\u0026#39;, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node01\u0026#39;, layout: \u0026#39;vbox\u0026#39;, children: [ \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp01\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;hbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node02\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node03\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp02\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;vbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node04\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node05\u0026#39;, size: { width: 25, height: 25 }, }, ] } ] }, \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp05\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;hbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp03\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;vbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node06\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node07\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp04\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;hbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node08\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node09\u0026#39;, size: { width: 25, height: 25 }, }, ] } ] }, \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp06\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;vbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node10\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node11\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node12\u0026#39;, size: { width: 25, height: 25 }, }, ] } ] } ] },] }; Layouting Nested Nodes By design, nested SNode do not obey the layout property of an SNode parent. This is because nested nodes are usually used to represent a graph hierarchy, and the layout of the children of a node is not relevant for the structure of the graph. In general, the position of those nodes should be the responsibility of the macro-layout engine.\nHowever, if you still need the micro-layout engine to control the position of nested nodes, this can be achieved by enabling the layoutableChildFeature in the inversify container.\nconfigureModelElement(context, \u0026#39;your node type\u0026#39;, SNodeImpl, YourNodeView, {enable: [layoutableChildFeature]}) ","description":"Layout Configuration Layout Options Alignment Padding Size Using SCompartments for Complex Layouts Layouting Nested Nodes The micro-layout refers to the layout of elements inside of a node, i.e. the layout of nested labels, buttons, etc. It is not to be confused with the macro-layout which refers to the layout of the entire graph, e.g. the position of nodes.\nLayout Configuration Any model element that implements or extends the SNode or SCompartment interface has an optional property layout that specifies the general layout of its children elements."},{"id":7,"href":"/docs/model-sources/","title":"Model Sources","parent":"Docs","content":" General usage Local Model Source Diagram Server Creating a Custom Model Source Proxy When drawing a diagram with Sprotty we need a place to define and update the schema of the diagram to draw. Sprotty uses model sources to do this. Sprotty currently offers two different model sources: The LocalModelSource for local models and the DiagramServer for remote ones. flowchart TD; ActionDispatcher ModelSource LocalModelSource DiagramServerProxy DiagramServer ActionDispatcher \u003c-.-\u003e|Action| ModelSource ModelSource --- LocalModelSource ModelSource --- DiagramServerProxy DiagramServerProxy \u003c-.-\u003e|Action| DiagramServer Regardless of where your model-source is located, Sprotty handles them in a similar fashion. All communication between ActionDispatcher and model source is always through actions and is bi-directional. This is a powerful feature of Sprotty as it allows both flexibility regarding where and how the Diagram is generated, as well as changing or updating and reacting to interactions with the diagram simultaneously.\nThe following sections will explain how to use and work with the different types of model sources.\nGeneral usage Regardless of the model source we are using, the first thing we have to do is to register our model source in the front-end DI-container like this:\nbind(TYPES.ModelSource).to(ModelSourceClassOrProxy).inSingletonScope(); After that, we can retrieve the model source with the following code to further configure and use it.\nconst modelSource = container.get\u0026lt;LocalModelSource\u0026gt;(TYPES.ModelSource); Local Model Source A LocalModelSource instance allows us to set and modify the model through function calls, and keeps the model schema saved locally. To see how to use this model source, let\u0026rsquo;s have a look at the following example:\nimport {SNode} from \u0026#39;sprotty-protocol\u0026#39;; export default runExample() { const container = createContainer(\u0026#39;sprotty-showcase\u0026#39;); const modelSource = container.get\u0026lt;LocalModelSource\u0026gt;(TYPES.ModelSource); modelSource.setModel({ type: \u0026#39;graph\u0026#39; children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;main_node\u0026#39;, text: \u0026#39;node1\u0026#39;, position: {x: 0, y: 0} } ] }); document.getElementById(\u0026#39;addButton\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { modelSource.addElements([ { parentId: \u0026#39;graph\u0026#39;, element: \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;new_node\u0026#39;, text: \u0026#39;new node\u0026#39;, position: {x: 100, y: 100} } }]) }) } In this example, we have a hard-coded data structure containing all the initial elements which are set in the model. Be aware that by defining the model this way we are defining the model schema - a data structure describing the model - and not the actual model itself. The model in this context means instances of the classes containing logic Sprotty uses for rendering. The model schema is used by Sprotty to generate the model. Due to this, we should use the interfaces for our nodes, edges, etc. from sprotty-protocol and not the classes from the sprotty main package. For disambiguation, model classes are suffixed with Impl in Sprotty, while interfaces (contained in the package sprotty-protocol) are not. This means that SNode is an interface, while SNodeImpl is a class.\nAfter defining the model schema we can then use methods like addElements() from our LocalModelSource to add new nodes at the click of a button. The LocalModelSource then handles updating the model and notifying the ActionDispatcher about the update, so that the view can receive an animated update.\nThrough methods like the ones outlined above, the LocalModelSource can also be used as a facade over the action-based API of Sprotty. It handles actions for bounds calculation and model updates.\nDiagram Server When the model needs to be generated from a remote source, like in a worker or from a server, we can use Sprotty\u0026rsquo;s DiagramServer model source. It communicates with the client through Action objects which can be serialized to plain JSON.\nOn the client-side, instead of registering an actual ModelSource we can use a DiagramServerProxy. The Proxy handles the communication and forwards actions to the ActionDispatcher. Out of the box, Sprotty offers the WebSocketDiagramServerProxy for communicating through WebSockets with the DiagramServer. Should a different form of communication be necessary we would have to create a custom proxy.\nUsing the WebSocketDiagramServerProxy is quite simple. We just need to call listen on the ModelSource and pass it the WebSocket we\u0026rsquo;re communicating with.\nconst modelSource = container.get\u0026lt;WebSocketDiagramServerProxy\u0026gt;(TYPES.ModelSource); modelSource.listen(websocket); For creating the DiagramServer itself, let\u0026rsquo;s look at an example.\n// Creating a new websocket server const wss = new WebSocketServer.Server({ port: 8080 }); // create our DiagramServices const elkFactory: ElkFactory = () =\u0026gt; new SocketElkServer(); const services: DiagramServices = { DiagramGenerator: new RandomGraphGenerator(), ModelLayoutEngine: new ElkLayoutEngine(elkFactory) } // Creating connection using websocket wss.on(\u0026#34;connection\u0026#34;, ws =\u0026gt; { const diagramServer = new DiagramServer(action =\u0026gt; { ws.send(JSON.stringify(action)); }, services) ws.on(\u0026#39;message\u0026#39; data =\u0026gt; { diagramServer.accept(data.action); }); }); In the example above, we assume we have a simple nodeJs WebSocket server and want to create a DiagramServer for it.\nAs we can see, there are two parts to creating the DiagramServer. First, we need a dispatch method to send actions from the server to the client. This can be as simple as calling ws.send() with the serialized action. Second, we need the DiagramServices. The DiagramServices type looks like this:\nexport interface DiagramServices { readonly DiagramGenerator: IDiagramGenerator readonly ModelLayoutEngine?: IModelLayoutEngine readonly ServerActionHandlerRegistry?: ServerActionHandlerRegistry } There are 3 components to the DiagramServices. One is mandatory, the other two are optional:\nThe DiagramGenerator which the server uses to create the schema of the Diagram Optionally the ModelLayoutEngine, like the ElkLayoutEngine from sprotty-elk, if we want to do server-side layouting Optionally the ServerActionHandlerRegistry for overwriting the default handling of incoming actions Creating a Custom Model Source Proxy In case communication between the DiagramServer and client does not work through WebSockets, for example when the DiagramServer is running in a worker or the sprotty client is in a vscode webview (see sprotty-vscode), we can easily implement our own proxy instead.\nexport class WebWorkerDiagramProxy extends DiagramServerProxy { constructor(private worker: Worker) { super() const proxy = this; worker.onmessage = function(event) { proxy.messageReceived(event.data) } } protected sendMessage(message: ActionMessage): void { this.worker.postMessage(JSON.stringify(message)); } } Following the example above, first we need to extend DiagramServerProxy. This already gives us most of our needed functionality and makes this proxy a ModelSource. Then we need to listen for incoming messages and pass them to the messageReceived() function, which deserializes and passes them to the ActionDispatcher. Lastly, we need to implement the sendMessage() method to allow actions coming from the ActionDispatcher to be transferred to the DiagramServer.\nNow our custom model source proxy is able to propagate all actions between the ActionDispatcher and our DiagramServer running in the worker, which gives us access to all of sprotty\u0026rsquo;s functionality.\n","description":"General usage Local Model Source Diagram Server Creating a Custom Model Source Proxy When drawing a diagram with Sprotty we need a place to define and update the schema of the diagram to draw. Sprotty uses model sources to do this. Sprotty currently offers two different model sources: The LocalModelSource for local models and the DiagramServer for remote ones. flowchart TD; ActionDispatcher ModelSource LocalModelSource DiagramServerProxy DiagramServer ActionDispatcher \u003c-.-\u003e|Action| ModelSource ModelSource --- LocalModelSource ModelSource --- DiagramServerProxy DiagramServerProxy \u003c-."},{"id":8,"href":"/docs/overview/","title":"Overview","parent":"Docs","content":" Action Dispatcher Action Model Source Command Stack Command SModel (SprottyModel) Viewer View Registry View The base architecture of Sprotty revolves around an unidirectional cyclic flow of information between three major components: the ActionDispatcher, the CommandStack, and the Viewer. This leads to a clear and easily testable flow of data which prevents feedback loops.\nflowchart TD; ActionDispatcher CommandStack Viewer ActionDispatcher --\u003e|Command| CommandStack CommandStack --\u003e|SModel| Viewer Viewer --\u003e|Action| ActionDispatcher Action Dispatcher The main role of the ActionDispatcher is to receive an Action and produce a corresponding command to be transmitted to the CommandStack using ActionHandlers. All operations on the diagram must be passed through the ActionDispatcher, so the CommandStack and the Viewer must never be invoked directly.\nThe ActionDispatcher also communicates with the ModelSource through Actions in a bidirectional manner, for example to inject external data into the loop or apply edits to the ModelSource.\nflowchart LR; ModelSource ActionDispatcher ModelSource --\u003e|Action| ActionDispatcher ActionDispatcher --\u003e|Action| ModelSource Action Actions are objects without behavior, JSON structures that describe what should happen but not how it should happen. As such, they can be serialized and serve as protocol messages that are exchanged between the client and the server. In actions, model elements are referred to by their IDs.\nModel Source There are two different ModelSources: the LocalModelSource offers an API to control the model directly in the client, while the DiagramServer delegates to a remote source, e.g. through a WebSocket or a VSCode extension.\nCommand Stack The CommandStack executes the commands it receives from the ActionDispatcher. It chains the promises returned by the execution methods and keeps an undo and a redo stack. It merges the current commands with the last one, e.g. to only keep the start and end point of a move from a drag operation. It is responsible for producing a graph model (namely SModel) and forwards it to the Viewer to be rendered.\nCommand Commands describe the behavior of their corresponding Action. They have the typical methods execute(), undo()and redo(), each of which take the current model and a command execution context as parameter, and return the new model or a promise for it. The latter serves to chain asynchronous commands such as animations.\nSModel (SprottyModel) The diagram is stored in an internal model called SModel. The root of the diagram is always an instance of SModelRootImpl and holds an index of the model to allow fast lookup of elements by ID. All elements of a diagram inherit SModelElementImpl which has a unique ID and a mandatory type referring to its View. The model elements are organized in a tree derived from the children and parent properties of each model element. It can be useful to introduce domain-specific information into the SModel. This can be achieved via creating new element classes that inherit from any related SModelElementImpl.\nflowchart BT; SModelElementImpl SShapeElementImpl SEdgeImpl SNodeImpl SPortImpl SLabelImpl CustomEdge CustomNode CustomPort CustomLabel SShapeElementImpl --\u003e SModelElementImpl SEdgeImpl --\u003e SModelElementImpl CustomEdge -.-\u003e SEdgeImpl SNodeImpl --\u003e SShapeElementImpl CustomNode -.-\u003e SNodeImpl SPortImpl --\u003e SShapeElementImpl CustomPort -.-\u003e SPortImpl SLabelImpl --\u003e SShapeElementImpl CustomLabel -.-\u003e SLabelImpl Viewer The Viewer is responsible for turning the internal model into its representation in the DOM. The conversion from an SModel to its representation in the DOM is not direct. Instead, Sprotty first creates a VirtualDOM and uses it to patch the actual DOM. This approach saves on expensive modification of the DOM by applying only the minimum amount of modification to it. The Viewer receives an SModel from the CommandStack and traverses it to apply a corresponding View to every element. The viewer is also responsible to add event listeners and animations using its Decorators. The received events should be converted to Actions and transferred to the ActionDispatcher.\nflowchart LR; Viewer ViewRegistry Views VirtualDOM DOM Viewer --\u003e ViewRegistry ViewRegistry --\u003e Views Views --\u003e|render| VirtualDOM VirtualDOM --\u003e|patch| DOM DOM --\u003e|event| Viewer View Registry The Viewer uses the ViewRegistry to look up the View for a graph model element using its ID.\nView A View knows how to turn a graph model element and its children into a virtual DOM node. It uses JSX technology and contains a render method producing one or a group of SVG elements.\n","description":"Action Dispatcher Action Model Source Command Stack Command SModel (SprottyModel) Viewer View Registry View The base architecture of Sprotty revolves around an unidirectional cyclic flow of information between three major components: the ActionDispatcher, the CommandStack, and the Viewer. This leads to a clear and easily testable flow of data which prevents feedback loops. flowchart TD; ActionDispatcher CommandStack Viewer ActionDispatcher --\u003e|Command| CommandStack CommandStack --\u003e|SModel| Viewer Viewer --\u003e|Action| ActionDispatcher Action Dispatcher The main role of the ActionDispatcher is to receive an Action and produce a corresponding command to be transmitted to the CommandStack using ActionHandlers."},{"id":9,"href":"/docs/smodel/","title":"SModel","parent":"Docs","content":" External Model Internal Model Elements Classes Inheritance SModelElementImpl SParentElementImpl SChildElementImpl SModelRootImpl ModelIndexImpl Graph Elements SGraphImpl SNodeImpl SPortImpl SEdgeImpl SLabelImpl SCompartmentImpl SGraphIndex ViewportRootElement SConnectableElementImpl SShapeElementImpl SRoutableElementImpl The SModel (short for SprottyModel) is the core data structure of Sprotty. It is a tree of model elements that can be rendered by a View. The root of the model is always an instance of SModelRootImpl or one of its derived class.\nFirst, we need to distinguish between two models: the internal model and the external model.\nThe internal model is used only in the CommandStack and the Viewer. It is a tree of model elements representing the current state of what is visible in the diagram. After a change has been applied via a Command. the CommandStack sends an updated version of the internal model to the Viewer which in turns renders the updated model using the provided View implementations.\nThe external model is used to transfer information between the model source and the Sprotty frontend. The external model must be serializable as JSON so that it can be easily transferred via network messages. Changes to the external model are applied through Actions, which contain the external model or parts of it. When the model source resides in the backend, the content of the diagram are controlled by a DiagramServer, which holds a copy of the external model.\nExternal Model The external model is tree of JSON-serializable objects. To facilitate its implementation, Sprotty provides a set of interfaces (in the sprotty-protocol package) that can be used to describe the external model. These interfaces have a class counterpart that is used in the internal model. The complete list of interfaces provided by Sprotty can be found here.\nInternal Model Elements The internal model is a tree of model elements implemented as classes. To avoid ambiguity with interfaces used in the external model, classes are named with the suffix Impl.\nClasses Inheritance flowchart BT; SModelElementImpl SParentElementImpl SChildElementImpl SModelRootImpl ModelIndexImpl SGraphImpl ViewportRootElement SNodeImpl SConnectableElementImpl SShapeElementImpl SPortImpl SEdgeImpl SRoutableElementImpl SLabelImpl SCompartmentImpl SGraphIndex SParentElementImpl --\u003e SModelElementImpl SChildElementImpl --\u003e SParentElementImpl SModelRootImpl --\u003e SParentElementImpl SGraphImpl --\u003e ViewportRootElement ViewportRootElement --\u003e SModelRootImpl SNodeImpl --\u003e SConnectableElementImpl SConnectableElementImpl --\u003e SShapeElementImpl SShapeElementImpl --\u003e SChildElementImpl SPortImpl --\u003e SConnectableElementImpl SEdgeImpl --\u003e SRoutableElementImpl SRoutableElementImpl --\u003e SChildElementImpl SLabelImpl --\u003e SShapeElementImpl SCompartmentImpl --\u003e SShapeElementImpl SGraphIndex --\u003e ModelIndexImpl SModelElementImpl This is the base class for all elements of the diagram model. This ensures that all elements in the model have a type and an id.\nProperties:\ntype: string: The type of the element. This value is used in the Sprotty configuration to specify the corresponding view for all elements of this type. id: string: The globally unique identifier of the element. features: FeatureSet - optional: A set of features that are enabled on the element. The list of features can be further configured in the dependency injection container. cssClasses: string[] - optional: A list of CSS classes that should be applied to the element. SParentElementImpl A parent element may contain children elements, thus the diagram model forms a tree.\nProperties:\nchildren: SChildElementImpl[]: The children of the element. Defaults to an empty array. Inheritance:\nSModelElementImpl\nSChildElementImpl A child element is contained in a parent element. All elements except for the model root are derived from SChildElementImpl. Every child element is also a parent element, thus it can contain children elements itself.\nProperties:\nparent: SParentElementImpl: The parent of the element. Inheritance:\nSParentElementImpl  SModelElementImpl\nSModelRootImpl This is the base class for the root element of the diagram model. It inherits from SParentElementImpl, therefore, actual model elements are contained in its children property.\nProperties:\ncanvasBounds: Bounds: The bounds of the canvas. This is used to determine the size of the diagram. Defaults to Bounds.EMPTY (i.e. {x: 0, y: 0, width: -1, height: -1}). revision: number- optional: The revision number of the model. This is incremented by Sprotty whenever the model is changed. This is used in the DiagramServer to ensure that the correct version of the model is used. Inheritance:\nSParentElementImpl  SModelElementImpl\nModelIndexImpl An index of all model elements. It is used to optimize the lookup of elements by their id.\nGraph Elements The base architecture of Sprotty does not assume that the visualization is based on nodes and edges. However, since it is a very common use-case, Sprotty provides a set of classes that can be used to build a graph-based diagram.\nSGraphImpl Root element of the diagram model.\nProperties:\nlayoutOptions: ModelLayoutOptions - optional: Options for the layout of the diagram. Inheritance:\nViewportRootModel  SModelRootImpl  SParentElement  SModelElementImpl\nSNodeImpl Model element for Nodes, which are the main entity in a graph. A node can be connected to another node via an edge. Such connection can be direct (i.e. the source or target of the edge is the node itself) or indirect (i.e. the source or target of the edge is a child port of the node).\nProperties:\nchildren: SChildElementImpl[] layout: string - optional selected: boolean: Indicates if the node is selected. Defaults to false. hoverFeedback: boolean: Indicates if the node should show hover feedback. Defaults to false. opacity: number: The opacity of the node. Defaults to 1. Inheritance:\nSConnectableElementImpl  SShapeElementImpl  SChildElementImpl  SParentElementImpl  SModelElementImpl\nDefault features:\nconnectableFeature deletableFeature selectFeature boundsFeature moveFeature layoutContainerFeature fadeFeature hoverFeedbackFeature popupFeature SPortImpl A port is a connection point for edges. It should always be contained in an SNodeImpl.\nProperties:\nselected: boolean: Indicates if the port is selected. Defaults to false. hoverFeedback: boolean: Indicates if the port should show hover feedback. Defaults to false. opacity: number: The opacity of the port. Defaults to 1. Inheritance:\nSConnectableElementImpl  SShapeElementImpl  SChildElementImpl  SParentElementImpl  SModelElementImpl\nDefault features:\nconnectableFeature selectFeature boundsFeature fadeFeature hoverFeedbackFeature SEdgeImpl These are the connectors for the diagram model. An edge has a source and a target. Each of which can either be a node or a port. The source and target elements are referenced by their id (inherited from SRoutableElementImpl) and can be resolved via the index stored in the root element.\nProperties;\nselected: boolean: Indicates if the edge is selected. Defaults to false. hoverFeedback: boolean: Indicates if the edge should show hover feedback. Defaults to false. opacity: number: The opacity of the edge. Defaults to 1. Inheritance:\nSRoutableElementImpl  SChildElementImpl  SParentElementImpl  SModelElementImpl\nDefault features:\neditFeature deletableFeature selectFeature fadeFeature hoverFeedbackFeature SLabelImpl A label represents some text to be displayed and attached to a node, compartment, port, or edge.\nProperties:\ntext: string: The text of the label. selected: boolean: Indicates if the label is selected. Defaults to false. alignment: Point: The alignment of the label. Defaults to Point.ORIGIN. opacity: number: The opacity of the label. Defaults to 1. edgePlacement: EdgePlacement - optional: The placement of the label on an edge. Defaults to EdgePlacement.NONE. rotate: boolean - true, if the label should be rotated to touch the edge tangentially side: EdgeSide - where is the label relative to the line\u0026rsquo;s direction. Possible values are \u0026lsquo;bottom\u0026rsquo;, \u0026rsquo;top\u0026rsquo;, \u0026rsquo;left\u0026rsquo;, \u0026lsquo;right\u0026rsquo;, and \u0026lsquo;on\u0026rsquo;. position: number - between 0 (source anchor) and 1 (target anchor) offset: number - space between label and edge/connected nodes moveMode: 'edge' | 'free' | 'none' - optional constrains where the label can be moved when move feature is enabled for the respective Label. edge means the label can be moved along the edge, free means the label can be moved freely, none means the label cannot moved. Defaults to edge. Inheritance:\nSShapeElementImpl  SChildElementImpl  SParentElementImpl  SModelElementImpl\nDefault features:\nboundsFeature alignFeature layoutableChildFeature edgeLayoutFeature fadeFeature SCompartmentImpl A compartment is used to group multiple child elements of a node or compartment, such as labels. Usually, a vbox or hbox layout is used to arrange these children.\nProperties:\nlayout: string - optional: The layout of the compartment. opacity: number: The opacity of the compartment. Defaults to 1. Inheritance:\nSShapeElementImpl  SChildElementImpl  SParentElementImpl  SModelElementImpl\nDefault features:\nboundsFeature layoutContainerFeature layoutableChildFeature fadeFeature SGraphIndex A specialized model index that tracks outgoing and incoming edges.\nInheritance:\nModelIndexImpl\nViewportRootElement Model root element that defines a viewport, so it transforms the coordinate system of its children with a scroll and zoom factor.\nProperties:\nscroll: Point: The scroll offset of the viewport. Defaults to {x: 0, y: 0}. zoom: number: The zoom factor of the viewport. Defaults to 1. position: Point: The position of the viewport. Defaults to {x: 0, y: 0}. size: Dimension: The size of the viewport. Defaults to {width: -1, height: -1}. Inheritance: SModelRootImpl  SParentElementImpl  SModelElementImpl\nSConnectableElementImpl A connectable element is one that can have outgoing and incoming edges. It can be the source or target element of an edge. There are two kinds of connectable elements: SNodes and SPorts.\nProperties:\nstrokeWidth: number: The stroke width of the element. Defaults to 0. Inheritance:\nSShapeElementImpl  SChildElementImpl  SParentElementImpl  SModelElementImpl\nSShapeElementImpl Abstract class for elements with a position and size.\nProperties:\nposition: Point: The position of the element. Defaults to {x: 0, y: 0}. size: Dimension: The size of the element. Defaults to {width: -1, height: -1}. layoutOptions: ModelLayoutOptions - optional: Options for the layout of the element. Inheritance:\nSChildElementImpl  SParentElementImpl  SModelElementImpl\nSRoutableElementImpl Abstract class for edges.\nProperties:\nrouterKind: string - optional: The kind of router to use for the edge. Sprotty provides an implementation of \u0026lsquo;polyline\u0026rsquo;, \u0026lsquo;manhattan\u0026rsquo;, and \u0026lsquo;bezier\u0026rsquo; routers. routingPoints: Point[] - optional: The routing points of the edge. Defaults to an empty array. sourceId: string: The id of the source element. targetId: string: The id of the target element. sourceAnchorCorrection: number - optional: The correction of the source anchor. This can be used to apply an offset to the anchor position of the source element. Defaults to 0. targetAnchorCorrection: number - optional: The correction of the target anchor. This can be used to apply an offset to the anchor position of the target element. Defaults to 0. To offset the anchor point of an edge\nInheritance:\nSChildElementImpl  SParentElementImpl  SModelElementImpl\n","description":"External Model Internal Model Elements Classes Inheritance SModelElementImpl SParentElementImpl SChildElementImpl SModelRootImpl ModelIndexImpl Graph Elements SGraphImpl SNodeImpl SPortImpl SEdgeImpl SLabelImpl SCompartmentImpl SGraphIndex ViewportRootElement SConnectableElementImpl SShapeElementImpl SRoutableElementImpl The SModel (short for SprottyModel) is the core data structure of Sprotty. It is a tree of model elements that can be rendered by a View. The root of the model is always an instance of SModelRootImpl or one of its derived class.\nFirst, we need to distinguish between two models: the internal model and the external model."},{"id":10,"href":"/","title":"Sprotty","parent":"","content":" Diagram Visualization Tools for Your Web Applications Eclipse Sprotty is an open source project enabling the creation of powerful diagramming tools and graphical visualizations. Fully customizable  Server and client-side diagramming  Easy integration  Powerful timesaver Get started Learn more\nSprotty provides a framework for rendering diagrams using the Scalable Vector Graphics (SVG) format, pluggable to powerful layout engines such as the Eclipse Layout Kernel (ELK). Sprotty is fully customizable , from the look of your diagram, down to its behavior. The example diagram shows part of a visual implementation of an electronic control unit used in the automotive domain (from ETAS EHANDBOOK). Try it live! Start exploring the diagram, hover over components, click on them, discover what Sprotty can do! Customizable and beautiful Sprotty makes it easy to create beautiful, interactive diagrams in web applications, with the ability to customize and integrate with external tools and services. From simple to advanced Sprotty provides a flexible and extensible framework that can be used for a wide range of diagramming needs, from simple flowcharts to advanced graphical editors that integrate with external services. Powerful timesaver With Sprotty, developers can save time and effort in creating powerful diagramming tools for their applications. At home in any kind of water... Sprotty can be used in any web application that supports web technologies such as HTML, CSS, and JavaScript. It is well suited for client-side diagramming, involving no server-side work whatsoever. It can also use server-side diagram generation for most complex use cases. Quick to hook... Sprotty can be integrated with various web frameworks such as React, Angular and Vue.js It can also be easily integrated into VSCode extensions. Many powerful graphical editors, such as Eclipse GLSP, are built on top of Sprotty! The following example shows a full integration between Sprotty and the Monaco Editor. The Monaco Editor runs a language server for a DSL created with Langium for creating state-machines. Edit the content of the editor and see changes transferred in real-time to the diagram!\nSprotty was first released in 2017 and has since been continuously developed and improved by a diverse community.\nFishing for professional support? Get help from the main contributors! The companies TypeFox and EclipseSource are specialized in custom development of diagram-based tools.\nStart using Eclipse Sprotty right now and become a part of the Sprotty school! About  Privacy Policy  Terms of Use  Copyright Agent  2023 by Eclipse Foundation ","description":"Diagram Visualization Tools for Your Web Applications Eclipse Sprotty is an open source project enabling the creation of powerful diagramming tools and graphical visualizations. Fully customizable  Server and client-side diagramming  Easy integration  Powerful timesaver Get started Learn more\nSprotty provides a framework for rendering diagrams using the Scalable Vector Graphics (SVG) format, pluggable to powerful layout engines such as the Eclipse Layout Kernel (ELK). Sprotty is fully customizable , from the look of your diagram, down to its behavior."},{"id":11,"href":"/docs/dependency-injection/","title":"Sprotty configuration and dependency injection","parent":"Docs","content":" Why dependency injection? The container Features Creating custom components Dependency Injection specialties Multi bindings Provider Bindings As seen in the getting started guide, Sprotty relies heavily on dependency injection (DI) through InversifyJs for the configuration of its various components. This chapter will take a closer look at how to work with this.\nWhy dependency injection? DI allows us to:\nnot care about the instantiation and life-cycle of service components manage singletons like the various registries without using the global scope easily mock components in tests exchange default implementations with custom ones with minimum code changes modularize the configuration of specific features and scenarios and merge these modules for the final application The container The DI-container is the main point of configuration. The standard in Sprotty is to name this file di.config.ts.\nexport const createContainer = (containerId: string) =\u0026gt; { const myModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { bind(TYPES.ModelSource).to(LocalModelSource).inSingletonScope(); const context = { bind, unbind, isBound, rebind }; configureModelElement(context, \u0026#39;graph\u0026#39;, SGraphImpl, SGraphView); configureModelElement(context, \u0026#39;task\u0026#39;, SNodeImpl, TaskNodeView); configureModelElement(context, \u0026#39;edge\u0026#39;, SEdgeImpl, PolylineEdgeView); configureViewerOptions(context, { needsClientLayout: false, baseDiv: containerId }); }); const container = new Container(); loadDefaultModules(container); container.load(myModule, edgeIntersectionModule); return container; }; The container is built from multiple modules. Through loadDefaultModules() all modules are loaded for default Sprotty functionalities. We can also load other optional modules like the edgeIntersectionModule for extra functionality.\nMost important is our own module where the core of the configuration happens. Here we can configure singleton scope classes like our model source or rebind default Sprotty components (for example the logger) to a custom implementation. We use Symbols for bindings instead of using classes directly. All Symbols can be found in the TYPES object.\nUsing configureModelElement we can link our model to specific view components through the type property. Meaning if we have the following SNode, in our model, Sprotty will try to convert this data structure to an instance of the actual SNodeImpl class and render it with the TaskNodeView.\n\u0026lt;SNode \u0026amp; TaskNode\u0026gt;{ type: \u0026#39;task\u0026#39;, id: \u0026#39;task01\u0026#39;, name: \u0026#39;First Task\u0026#39;, isFinished: true, ... } Lastly, we need to configure our viewer options. Here we configure all the DOM elements needed by Sprotty, for example the base div inside of which our diagram is rendered, or the hidden div used by the first render cycle for determining micro layout. Another thing configured here is the layout. Specifically, if layout calculation should be done on client-side, server-side or both. This also determines the protocol spoken by the client and server.\nFeatures Model elements can further be configured through features.\nconfigureModelElement(context, \u0026#39;task\u0026#39;, SNodeImpl, TaskNodeView, { enable: [customFeature], disable: [moveFeature] }); the configureModelElement method takes an optional object as the last parameter containing arrays for enabled and disabled features, which in turn contain Symbols representing those features. Through this, we can disable default functionality like dragging or selecting nodes and add functionality, either custom or loaded from other non-default modules.\nCreating custom components As described previously Sprotty uses InversifyJs for dependency injection. That means when creating custom features, views, etc. we have to use this too. As an example, let\u0026rsquo;s look at Sprotty\u0026rsquo;s PolylineEdgeView.\n@injectable() export class PolylineEdgeView extends RoutableView { @inject(EdgeRouterRegistry) edgeRouterRegistry: EdgeRouterRegistry; ... } The most important thing for our component to be made available in Sprotty is annotating it with @injectable(). Otherwise the dependency injection won\u0026rsquo;t work.\nNow, as seen in the example above, we can just bind it in the container like this:\nconfigureModelElement(context, \u0026#39;edge\u0026#39;, SEdge, PolylineEdgeView); After that we can use all features of inversifyJs and inject other components registered in our container with @inject(...)\nFor more information on inversifyJs have a look to their documentation\nDependency Injection specialties Multi bindings Sometimes there is more than one implementation bound to a specific interface in Sprotty. This is when we use multi-bindings. Here is an example of the VNodeDecorator.\n@multiInject(TYPES.VNodePostprocessor)@optional() protected postprocessors: VNodePostprocessor[] Provider Bindings Sprotty\u0026rsquo;s circular event flow introduces a cyclic dependency between the components ActionDispatcher, CommandStack and Viewer. To handle these, we have to use provider bindings like this:\n// action-dispatcher.ts export type IActionDispatcherProvider = () =\u0026gt; Promise\u0026lt;IActionDispatcher\u0026gt;; // di.config.ts bind(TYPES.IActionDispatcher).to(ActionDispatcher).inSingletonScope(); bind(TYPES.IActionDispatcherProvider).toProvider\u0026lt;IActionDispatcher\u0026gt;(ctx =\u0026gt; { return () =\u0026gt; { return new Promise\u0026lt;IActionDispatcher\u0026gt;((resolve) =\u0026gt; { resolve(ctx.container.get\u0026lt;IActionDispatcher\u0026gt;(TYPES.IActionDispatcher)); }); }; }); ","description":"Why dependency injection? The container Features Creating custom components Dependency Injection specialties Multi bindings Provider Bindings As seen in the getting started guide, Sprotty relies heavily on dependency injection (DI) through InversifyJs for the configuration of its various components. This chapter will take a closer look at how to work with this.\nWhy dependency injection? DI allows us to:\nnot care about the instantiation and life-cycle of service components manage singletons like the various registries without using the global scope easily mock components in tests exchange default implementations with custom ones with minimum code changes modularize the configuration of specific features and scenarios and merge these modules for the final application The container The DI-container is the main point of configuration."},{"id":12,"href":"/docs/styling/","title":"Styling","parent":"Docs","content":" Predefined Styling Available Views Default CSS Classes Using Subtypes for Styling Styling on a Per-Element Basis Styling from Custom Views Styling on User Interaction Sprotty is designed to be highly customizable. Styling of diagram elements is done using CSS, preferably using CSS classes. There are several ways to apply styles to an element depending on the level of granularity you need.\nPredefined Styling Available Views Sprotty comes with a handful of views that can be used to represent nodes, edges, and labels of your diagram. These views correspond to the most common SVG elements such as rect, circle, text, and path.\nThe following views can be used for visualizing nodes and ports:\nCircularNodeView: A circular representation of a node. Produces a circle SVG element. RectangularNodeView: A rectangular representation of a node. Produces a rect SVG element. DiamondNodeView: A diamond-shaped representation of a node. Produces a polygon SVG element. For representing edges, the following views are available:\nPolylineEdgeView: A succession of straight lines between two nodes. Produces a path SVG element. JumpingPolylineEdgeView: A succession of straight lines between two nodes with an arc where two or more edges intersect. Produces a path SVG element. PolylineEdgeViewWithGapsOnIntersections: A succession of straight lines between two nodes with a gap where two or more edges intersect. Produces a path SVG element. BezierCurveEdgeView: An succession of Bezier curves. Produces a path SVG element. For representing labels, the following view is available:\nSLabelView: A simple text label. Produces a text SVG element. Default CSS Classes Those default views assume that your are using the default implementations of diagram elements, namely SGraphImpl, SNodeImpl, SPortImpl, SEdgeImpl, and SLabelImpl.\nThe default views listed above use the following CSS classes to style the SVG elements:\nsprotty-graph: class for the root SVG element of the diagram. sprotty-node: class for the SVG element representing a node. sprotty-port: class for the SVG element representing a port. sprotty-edge: class for the SVG element representing an edge. sprotty-label: class for the SVG element representing a label. By using those CSS classes, you can easily style all nodes, ports, edges, and labels of your diagram in a uniform way.\nUsing Subtypes for Styling When dealing with diagrams with different types of nodes, ports, edges, or labels, it is common to want different styling for each type. Using the default CSS classes is not enough in this case as it would apply the same style to all nodes, ports, edges, or labels.\nBy convention, Sprotty uses the type property, which is a string of the shape main-type:sub-type, to distinguish between different types of diagram elements. For example, a node of type node:my-node has the main type node and the sub-type my-node.\nUsing this convention, you can add a CSS class for each diagram element sub-type. For example:\nA node of type node:my-node using the RectangularNodeView would have the following CSS classes: sprotty-node and my-node. A node of type node:my-other-node using the RectangularNodeView would have the following CSS classes: sprotty-node and my-other-node. This allows for more control over the styling of your diagram elements.\nStyling on a Per-Element Basis If the granularity of elements base type and sub-type is not enough for your use case, you can also style each diagram element individually. This can be done by adding a cssClasses property to the SModelElement that you want to style. This property should be an array of strings representing the CSS classes you want to apply to the element.\nconst myNode: SNode = { id: \u0026#39;node1\u0026#39;, type: \u0026#39;node:my-node\u0026#39;, cssClasses: [\u0026#39;special-node\u0026#39;, \u0026#39;some-other-css-class\u0026#39;] ... }; Assuming that this node is implementing the RectangularNodeView, the resulting SVG element would have the following CSS classes: sprotty-node, my-node, special-node, and some-other-css-class.\nStyling from Custom Views The highest level of control over the styling of your diagram elements is achieved by creating custom views. By creating a custom view, you can define the exact SVG elements that should be used to represent your diagram elements and apply any CSS classes you want.\nTo add a class to an SVG element, you need to use the class-my-class={boolean} convention inside of the SVG element. For example:\n\u0026lt;rect class-my-class={true}\u0026gt; Sprotty will internally convert this to the expected class attribute if the boolean is true.\nThis convention can be used to apply CSS classes to the SVG elements if a certain condition is met. For example, you could use this to apply a CSS class to an element if a certain property meets a condition:\nclass MyNodeImpl extends SNodeImpl { value: number; } class MyNodeView extends ShapeView { render(node: MyNodeImpl, context: RenderingContext, args?: ViewArgs): VNode | undefined { return \u0026lt;g\u0026gt; \u0026lt;rect x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34; width={node.size.width} height={node.size.height} class-sprotty-node={true} class-low-value={node.value \u0026lt; 10} class-high-value={node.value \u0026gt;= 10} /\u0026gt; {context.renderChildren(node)} \u0026lt;/g\u0026gt;; } } Styling on User Interaction Taking advantage of the conditional CSS classes, you can also apply styles to your diagram elements based on user interaction. For example, you could apply a CSS class to a node when it is selected. Without going into the details of how to handle user interaction, let\u0026rsquo;s look at how Sprotty\u0026rsquo;s default views handle this.\nSNodeImpl has the default feature selectFeature, meaning that when a node is selected, its selected property is set to true. This property can be used in the corresponding view to add a CSS class to the selected element. For example in the RectangularNodeView:\nexport class RectangularNodeView extends ShapeView { render(node: Readonly\u0026lt;SShapeElementImpl \u0026amp; Hoverable \u0026amp; Selectable\u0026gt;, context: RenderingContext, args?: IViewArgs): VNode | undefined { if (!this.isVisible(node, context)) { return undefined; } return \u0026lt;g\u0026gt; \u0026lt;rect class-sprotty-node={node instanceof SNodeImpl} class-sprotty-port={node instanceof SPortImpl} class-mouseover={node.hoverFeedback} class-selected={node.selected} x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34; width={Math.max(node.size.width, 0)} height={Math.max(node.size.height, 0)}\u0026gt;\u0026lt;/rect\u0026gt; {context.renderChildren(node)} \u0026lt;/g\u0026gt;; } } Note the class-selected={node.selected}. This will apply the CSS class selected to the SVG element when the selected property of the node is true.\nSimilarly, you can see that the class-mouseover={node.hoverFeedback} applies the CSS class mouseover to the SVG element when the hoverFeedback property of the node is true. For this the hoverFeedbackFeature must be enabled on the node.\n","description":"Predefined Styling Available Views Default CSS Classes Using Subtypes for Styling Styling on a Per-Element Basis Styling from Custom Views Styling on User Interaction Sprotty is designed to be highly customizable. Styling of diagram elements is done using CSS, preferably using CSS classes. There are several ways to apply styles to an element depending on the level of granularity you need.\nPredefined Styling Available Views Sprotty comes with a handful of views that can be used to represent nodes, edges, and labels of your diagram."},{"id":13,"href":"/docs/svg-rendering/","title":"SVG Rendering","parent":"Docs","content":" Virtual DOM Views Layouting Client Layout Server Layout Sprotty transforms a given SModel to its representation in the DOM in the form of a hierarchy of SVG elements. An SModel is composed of SModelElements, and each SModelElement has a type property that is associated to a single corresponding View. The ViewRegistry keeps a map of the correspondence between an element type and a view. These model elements are organized in the virtual DOM before being rendered as actual SVG elements in the DOM.\nVirtual DOM The virtual DOM is a tree-based, partial or complete representation of the DOM content. In our context, the virtual DOM contains a representation of our diagram SVG elements and their hierarchy. For every update made to the diagram, Sprotty generates a new SModel through the CommandStack and forwards it to the Viewer. Updates are often limited to a specific node or group of nodes and it would be unnecessarily expensive to have to re-render the entire diagram for each update. It is more efficient to apply minimal updates to directly impacted DOM elements. Sprotty relies on Snabbdom for handling elements in the virtual DOM and applying minimal changes the DOM through patching.\nViews Views are at the center of Sprotty\u0026rsquo;s rendering mechanism. They are classes implementing the IView interface and have a render() method that describes the SVG elements to be rendered for a given SModelElement type. Views use the TSX syntax, which allow combining HTML and TypeScript code to define elements, and therefore needs to reside inside of files with the .tsx extension.\nLet\u0026rsquo;s have a look at the definition of the NodeView from the Class Diagram example:\n@injectable() export class NodeView extends RectangularNodeView { override render(node: Readonly\u0026lt;SNodeImpl\u0026gt;, context: RenderingContext, args?: IViewArgs): VNode | undefined { if (!this.isVisible(node, context)) { return undefined; } return \u0026lt;g\u0026gt; \u0026lt;rect class-sprotty-node={true} class-node-package={node.type === \u0026#39;node:package\u0026#39;} class-node-class={node.type === \u0026#39;node:class\u0026#39;} class-mouseover={node.hoverFeedback} class-selected={node.selected} x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34; width={Math.max(node.size.width, 0)} height={Math.max(node.size.height, 0)}\u0026gt;\u0026lt;/rect\u0026gt; {context.renderChildren(node)} \u0026lt;/g\u0026gt;; } } The class NodeView extends RectangularNodeView which is a default View in Sprotty, ultimately implementing IView. Don\u0026rsquo;t forget to add the class decorator @injectable(), which is necessary for the Dependency Injection mechanism.\nThe render() method is the core of the View. It takes node \u0026ndash; that is the model element to be rendered - as an argument, a RenderingContext, and an optional args object. View implementations should first check whether the node should be rendered at all. This is an optimization step, as we only want to render SVG elements that are inside of the visible viewport and not hidden by some other user-defined filter. Eventually, the render() method returns a VNode which is Snabbdom\u0026rsquo;s virtual representation of a DOM element. This VNode can hold one and only one root element, therefore we need to group our SVG elements inside of a container element g. The SVG elements can be styled using CSS classes using Snabbdom\u0026rsquo;s notation. Classes are dynamically toggled with expressions of the form class-X={boolean expression}, with the class- prefix followed by the name of the class and a boolean expression to determine if the class should be toggled or not. In our example, the rect element created by the NodeView could have a class of sprotty-node, node-package, node-class, mouseover, selected, or any combination of those depending of the respective boolean expressions. It is then easy to style elements with CSS based on class names.\nOther attributes like width, height, and position are also defined here. Please note that the position is set at x=\u0026quot;0\u0026quot; y=\u0026quot;0\u0026quot; since the actual position will be determined by the layout engine later on.\nFinally, we render children of the node with the renderChildren() method from the RenderingContext. We strongly advocate for keeping the View\u0026rsquo;s responsibility to render only the SVG that is specific for the given node. Any child (e.g. labels, buttons, children nodes) should be rendered in their own View. This keeps the code better organized and removes the complexity of having to implement the layout of nested elements such as labels in the View itself and instead delegates this responsibility to the layout engine.\nLayouting It is important to distinguish two types of layout:\nThe client layout (or micro-layout) which deals with the layout of a node\u0026rsquo;s children. The server layout (or macro-layout) which deals with the overall shape of the diagram, placement of nodes and edges. Client Layout The client layout, a.k.a. micro-layout, occurs first. In this phase, Sprotty computes the position and size for elements that add some visual information such as labels to nodes and edges. Different layouts are selected using the layout property of a SNode or SCompartment. The values of the layout property can be:\nhbox for an horizontal layout. vbox for a vertical layout. stack for a stacking of children elements. The micro-layout is computed in two phases:\nA RequestBoundAction is received and the model is rendered invisibly (e.g. by assigning a width and height of zero to the elements). The locally used fonts and CSS styles are applied during this rendering phase. The resulting size information is used to invoke the selected layouts and the updated bounds are written into a ComputedBoundAction. The bounds stored in the ComputedBoundAction are applied to the model and initiates the visible rendering of the updated model with SetModelAction or UpdateModelAction. In depth documentation about the micro-layouting can be found here\nServer Layout The server layout, a.k.a. macro-layout takes place after the client layout. This is configured with an implementation of the ILayoutEngine interface. This takes care of the general shape of the diagram and computes the position of nodes and edges. Sprotty provides a package to use the Eclipse Layout Kernel(ELK), a JAVA-based automatic layout engine with several standard algorithms, but it is also of course possible to implement your own.\n","description":"Virtual DOM Views Layouting Client Layout Server Layout Sprotty transforms a given SModel to its representation in the DOM in the form of a hierarchy of SVG elements. An SModel is composed of SModelElements, and each SModelElement has a type property that is associated to a single corresponding View. The ViewRegistry keeps a map of the correspondence between an element type and a view. These model elements are organized in the virtual DOM before being rendered as actual SVG elements in the DOM."},{"id":14,"href":"/tags/","title":"Tags","parent":"Sprotty","content":"","description":""},{"id":15,"href":"/docs/user-interaction/","title":"User Interaction","parent":"Docs","content":" Interacting with a Sprotty Diagram Interacting with a Sprotty Diagram Sprotty offers multiple mouse and keyboard interactions by default listed in the following tables. The CTRL key in the following is equal to the CMD key on Mac.\nMouse left-click: toggle selection CTRL-click: add to/remove from selection left-click : drag move selection (when on selected element) left-click : drag pan viewport (when on diagram background) mouse wheel: zoom Touchpad click toggle selection drag move selection (when on selected element) two-finger pan up/down zoom zoom zoom Keys CTRL-SHIFT-A select all CTRL-SHIFT-C center selection, or if nothing is selected center the entire diagram CTRL-SHIFT-E export diagram to SVG CTRL-SHIFT-F zoom selection to fill the entire canvas, or if nothing is selected zoom the entire diagram CTRL-Z undo CTRL-SHIFT-Z redo ","description":" Interacting with a Sprotty Diagram Interacting with a Sprotty Diagram Sprotty offers multiple mouse and keyboard interactions by default listed in the following tables. The CTRL key in the following is equal to the CMD key on Mac.\nMouse left-click: toggle selection CTRL-click: add to/remove from selection left-click : drag move selection (when on selected element) left-click : drag pan viewport (when on diagram background) mouse wheel: zoom Touchpad click toggle selection drag move selection (when on selected element) two-finger pan up/down zoom zoom zoom Keys CTRL-SHIFT-A select all CTRL-SHIFT-C center selection, or if nothing is selected center the entire diagram CTRL-SHIFT-E export diagram to SVG CTRL-SHIFT-F zoom selection to fill the entire canvas, or if nothing is selected zoom the entire diagram CTRL-Z undo CTRL-SHIFT-Z redo "}]