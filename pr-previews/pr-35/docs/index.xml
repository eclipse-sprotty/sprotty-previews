<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on Sprotty</title><link>/docs/</link><description>Recent content in Docs on Sprotty</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Communication and Protocols</title><link>/docs/actions-and-protocols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/actions-and-protocols/</guid><description>Actions ComputedBoundsAction RequestBoundsAction RequestModelAction SetModelAction UpdateModelAction Protocols 1. No Layout Computation / Server-Only Layout 2. Client-Only Layout 3. Client and Server Layout Sprotty uses actions to communicate between ModelSource and ActionDispatcher regardless if the model source is local or remote. The core of this communication follows specific protocols. This Chapter will give an overview of these protocols and their used actions.
Actions Actions are plain JSON serializable objects so that they can easily be passed through all kinds of APIs.</description></item><item><title>Creating Custom Interaction</title><link>/docs/custom-interactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/custom-interactions/</guid><description>Buttons and Button Handlers Mouse and Keyboard Listeners Projection Bars Buttons and Button Handlers Buttons in Sprotty work similarly to the other model elements, but they enable you to directly hook up handlers that react to the push of a button. As in the other examples with other types of nodes, we first need to define the model and view class and define its type ID. in addition, we also need to define a button handler of type IButtonHandler.</description></item><item><title>Features</title><link>/docs/features/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/features/</guid><description>alignFeature boundsFeature connectableFeature creatingOnDragFeature decorationFeature deletableFeature edgeLayoutFeature editFeature editLabelFeature expandFeature exportFeature fadeFeature hoverFeedbackFeature layoutableChildFeature layoutContainerFeature moveFeature nameFeature openFeature popupFeature selectFeature viewportFeature withEditLabelFeature Features can be viewed as a set of functionalities that a given element can support. They can enrich the behavior and usability of the diagram model.
SModelElements can have default features that will apply to all model elements that are instance of this SModelElement.Default features are specified in the DEFAULT_FEATURES field, which can be overridden in inherited classes.</description></item><item><title>Getting Started</title><link>/docs/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/</guid><description>Our &amp;lsquo;Getting Started&amp;rsquo; example consists of a simple application that displays a list of tasks, their status, and the relationship between them in a HTML page.
The main steps to integrate Sprotty into our application are as follows:
Set-up your application. Define your model by creating sub-interfaces of SModelElement. Implement views to generate SVGs for each type of model element. Configure the diagram through dependency injection. Connect to a model source, either local or remote Fast-Forward With Yeoman If you&amp;rsquo;d like to skip the manual steps below and create a Sprotty-based project right away, you can use the Yeoman generator:</description></item><item><title>Introduction</title><link>/docs/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/introduction/</guid><description>Sprotty is a next-generation, open-source diagramming framework built with web-technologies.
Some selected features:
Fast, scalable SVG rendering that is compatible with all modern browsers and stylable with CSS Animations built into the core Support for a distributed runtime with client and server Fast, reactive client architecture implemented in TypeScript Java or Node.js based server architecture Configuration via dependency injection Integrations with Xtext, Langium, the Language Server Protocol, VS Code and Theia Can be run as a rich-client as well as in the browser Where to start?</description></item><item><title>Micro-layout</title><link>/docs/micro-layout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/micro-layout/</guid><description>Layout Configuration Layout Options Alignment Padding Size Using SCompartments for Complex Layouts Layouting Nested Nodes The micro-layout refers to the layout of elements inside of a node, i.e. the layout of nested labels, buttons, etc. It is not to be confused with the macro-layout which refers to the layout of the entire graph, e.g. the position of nodes.
Layout Configuration Any model element that implements or extends the SNode or SCompartment interface has an optional property layout that specifies the general layout of its children elements.</description></item><item><title>Model Sources</title><link>/docs/model-sources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/model-sources/</guid><description>General usage Local Model Source Diagram Server Creating a Custom Model Source Proxy When drawing a diagram with Sprotty we need a place to define and update the schema of the diagram to draw. Sprotty uses model sources to do this. Sprotty currently offers two different model sources: The LocalModelSource for local models and the DiagramServer for remote ones. flowchart TD; ActionDispatcher ModelSource LocalModelSource DiagramServerProxy DiagramServer ActionDispatcher &lt;-.->|Action| ModelSource ModelSource --- LocalModelSource ModelSource --- DiagramServerProxy DiagramServerProxy &lt;-.</description></item><item><title>Overview</title><link>/docs/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/overview/</guid><description>Action Dispatcher Action Model Source Command Stack Command SModel (SprottyModel) Viewer View Registry View The base architecture of Sprotty revolves around an unidirectional cyclic flow of information between three major components: the ActionDispatcher, the CommandStack, and the Viewer. This leads to a clear and easily testable flow of data which prevents feedback loops.
flowchart TD; ActionDispatcher CommandStack Viewer ActionDispatcher -->|Command| CommandStack CommandStack -->|SModel| Viewer Viewer -->|Action| ActionDispatcher Action Dispatcher The main role of the ActionDispatcher is to receive an Action and produce a corresponding command to be transmitted to the CommandStack using ActionHandlers.</description></item><item><title>SModel</title><link>/docs/smodel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/smodel/</guid><description>External Model Internal Model Elements Classes Inheritance SModelElementImpl SParentElementImpl SChildElementImpl SModelRootImpl ModelIndexImpl Graph Elements SGraphImpl SNodeImpl SPortImpl SEdgeImpl SLabelImpl SCompartmentImpl SGraphIndex ViewportRootElement SConnectableElementImpl SShapeElementImpl SRoutableElementImpl The SModel (short for SprottyModel) is the core data structure of Sprotty. It is a tree of model elements that can be rendered by a View. The root of the model is always an instance of SModelRootImpl or one of its derived class.
First, we need to distinguish between two models: the internal model and the external model.</description></item><item><title>Sprotty configuration and dependency injection</title><link>/docs/dependency-injection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/dependency-injection/</guid><description>Why dependency injection? The container Features Creating custom components Dependency Injection specialties Multi bindings Provider Bindings As seen in the getting started guide, Sprotty relies heavily on dependency injection (DI) through InversifyJs for the configuration of its various components. This chapter will take a closer look at how to work with this.
Why dependency injection? DI allows us to:
not care about the instantiation and life-cycle of service components manage singletons like the various registries without using the global scope easily mock components in tests exchange default implementations with custom ones with minimum code changes modularize the configuration of specific features and scenarios and merge these modules for the final application The container The DI-container is the main point of configuration.</description></item><item><title>sprotty-elk</title><link>/docs/sprotty-elk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/sprotty-elk/</guid><description>Configuration Create a new Elk Factory Bind the ElkFactory to the ContainerModule Bind the ElkLayoutEngine to the ContainerModule Bind the LayoutConfigurator to the ContainerModule Load the ElkLayoutModule to the Container Process Transformation of an SModel to an ELK graph Preprocessing Layout Postprocessing Back to the SModel The sprotty-elk module provides a layout engine for Sprotty diagrams based on the Eclipse Layout Kernel (ELK).
Configuration In order to use ELK with Sprotty, several steps need to be done in order to inject the required components into the Sprotty container.</description></item><item><title>Styling</title><link>/docs/styling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/styling/</guid><description>Predefined Styling Available Views Default CSS Classes Using Subtypes for Styling Styling on a Per-Element Basis Styling from Custom Views Styling on User Interaction Sprotty is designed to be highly customizable. Styling of diagram elements is done using CSS, preferably using CSS classes. There are several ways to apply styles to an element depending on the level of granularity you need.
Predefined Styling Available Views Sprotty comes with a handful of views that can be used to represent nodes, edges, and labels of your diagram.</description></item><item><title>SVG Rendering</title><link>/docs/svg-rendering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/svg-rendering/</guid><description>Virtual DOM Views Layouting Client Layout Server Layout Sprotty transforms a given SModel to its representation in the DOM in the form of a hierarchy of SVG elements. An SModel is composed of SModelElements, and each SModelElement has a type property that is associated to a single corresponding View. The ViewRegistry keeps a map of the correspondence between an element type and a view. These model elements are organized in the virtual DOM before being rendered as actual SVG elements in the DOM.</description></item><item><title>User Interaction</title><link>/docs/user-interaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/user-interaction/</guid><description> Interacting with a Sprotty Diagram Interacting with a Sprotty Diagram Sprotty offers multiple mouse and keyboard interactions by default listed in the following tables. The CTRL key in the following is equal to the CMD key on Mac.
Mouse left-click: toggle selection CTRL-click: add to/remove from selection left-click : drag move selection (when on selected element) left-click : drag pan viewport (when on diagram background) mouse wheel: zoom Touchpad click toggle selection drag move selection (when on selected element) two-finger pan up/down zoom zoom zoom Keys CTRL-SHIFT-A select all CTRL-SHIFT-C center selection, or if nothing is selected center the entire diagram CTRL-SHIFT-E export diagram to SVG CTRL-SHIFT-F zoom selection to fill the entire canvas, or if nothing is selected zoom the entire diagram CTRL-Z undo CTRL-SHIFT-Z redo</description></item></channel></rss>