[{"id":0,"href":"/docs/actions-reference/","title":"Actions","parent":"Docs","content":" Action RequestAction ResponseAction RejectAction RequestModelAction SetModelAction UpdateModelAction SetPopupModelAction SetBoundsAction RequestBoundsAction ComputedBoundsAction LoggingAction SelectAction SelectAllAction GetSelectionAction SelectionResult CollapseExpandAction CollapseExpandAllAction OpenAction LayoutAction CenterAction FitToScreenAction SetViewportAction GetViewportAction ViewportResult BringToFrontAction UndoAction RedoAction MoveAction HoverFeedbackAction CreateElementAction DeleteElementAction ApplyLabelEditAction ReconnectAction InitializeCanvasBoundsAction SetUIExtensionVisibilityAction EditLabelAction SwitchEditModeAction AddRemoveBezierSegmentAction CommitModelAction RequestExportSvgAction ExportSvgAction Action An Action represents an interaction with the diagram. It is a plain data structure and is transferable between the client and the server. It holds information about the type of action in the kind property, which is a unique string identifier for the action type.\nA basic Action is a \u0026ldquo;fire and forget\u0026rdquo; message and does not require a response. If a response is required, the RequestAction interface should be used.\nexport interface Action { kind: string; } RequestAction A RequestAction should ultimately be answered by a ResponseAction. The requestId property is used to match the request with the response.\nexport interface RequestAction extends Action { requestId: string; } ResponseAction A ResponseAction is sent as a response to a RequestAction. The responseId property is used to match the response with the request.\nexport interface ResponseAction extends Action { responseId: string; } RejectAction A RejectAction should be fired to indicate when a request has failed. It contains a message property with a human-readable error message and an optional detail property with additional information.\nexport interface RejectAction extends ResponseAction { kind: typeof RejectAction.KIND // \u0026#39;rejectRequest\u0026#39; message: string detail?: JsonAny } RequestModelAction A RequestModelAction is used by the client to request the server to request a model. This is usually the first message to be sent to the source and is also used to initiate the communication.\nexport interface RequestModelAction extends RequestAction\u0026lt;SetModelAction\u0026gt; { kind: typeof RequestModelAction.KIND // \u0026#39;requestModel\u0026#39; options?: JsonMap } SetModelAction A SetModelAction is used by the server to send the client the model to be set. If a model is already present, it will be replaced by the one held in the newRoot property.\nexport interface SetModelAction extends ResponseAction { kind: typeof SetModelAction.KIND // \u0026#39;setModel\u0026#39; newRoot: SModelRoot } Associated Command: SetModelCommand\nUpdateModelAction An UpdateModelAction is used to update the model on the client side. If no model is present, it behaves as a SetModelAction. If a model is present, the newRoot property is used to update the model. The matches property is used to match the new model elements with the existing ones. If animate is set to true, the model update will be animated. The cause property can be used to specify the action that caused the model update.\nexport interface UpdateModelAction { kind: typeof UpdateModelAction.KIND // \u0026#39;updateModel\u0026#39; newRoot?: SModelRoot matches?: Match[] animate?: boolean cause?: Action } Associated Command: `UpdateModelCommand` ## RequestPopupModelAction A `RequestPopupModelAction` is triggered when the mouse pointer overs an element and the client requests the server to provide a popup model for the element. The `elementId` property is used to identify the element being hovered, and the `bounds` property is used to specify the bounds of the popup. ```typescript export interface RequestPopupModelAction extends RequestAction\u0026lt;SetPopupModelAction\u0026gt; { kind: typeof RequestPopupModelAction.KIND // \u0026#39;requestPopupModel\u0026#39; elementId: string bounds: Bounds } SetPopupModelAction A SetPopupModelAction is used by the server to send the client the popup model to be set. The newRoot property holds the popup model. An EMPTY_ROOT can be used as the newRoot to remove the popup.\nexport interface SetPopupModelAction extends ResponseAction { kind: typeof SetPopupModelAction.KIND // \u0026#39;setPopupModel\u0026#39; newRoot: SModelRoot } Associated Command: SetPopupModelCommand\nSetBoundsAction A SetBoundsAction is used to set the bounds of the elements in the model. The bounds property holds an array of ElementAndBounds objects, each of which contains the elementId and the position and size of the element.\nexport interface SetBoundsAction extends Action { kind: typeof SetBoundsAction.KIND // \u0026#39;setBounds\u0026#39; bounds: ElementAndBounds[] } Associated Command: SetBoundsCommand\nRequestBoundsAction A RequestBoundsAction is sent from the server to the client to request the bounds of all elements in the model. The model is rendered invisibly so that the bounds can be derived from the DOM.\nexport interface RequestBoundsAction extends RequestAction\u0026lt;ComputedBoundsAction\u0026gt; { kind: typeof RequestBoundsAction.KIND newRoot: SModelRoot } Associated Command: RequestBoundsCommand\nComputedBoundsAction A ComputedBoundsAction is used by the client to send the server the computed bounds of the elements in the model as a response to a RequestBoundsAction.\nexport interface ComputedBoundsAction extends ResponseAction { kind: typeof ComputedBoundsAction.KIND bounds: ElementAndBounds[] revision?: number alignments?: ElementAndAlignment[] } LoggingAction A LoggingAction is used to transmit logging data from one place to another.\nexport interface LoggingAction extends Action { kind: typeof LoggingAction.KIND; severity: string time: string caller: string message: string params: string[] } SelectAction A SelectAction is triggered when the user changes the selection in the diagram. The selectedElementsIDs property holds the IDs of the elements that have been selected, and the deselectedElementsIDs property holds the IDs of the elements that have been deselected.\nThe action can be forwarded to the server so it can react to the selection change.\nThis action can also be sent from the server to the client to update the selection state programmatically.\nexport interface SelectAction { kind: typeof SelectAction.KIND selectedElementsIDs: string[] deselectedElementsIDs: string[] } Associated Command: SelectCommand\nSelectAllAction A SelectAllAction is used to select or deselect all elements in the model. The select property is used to specify whether the elements should be selected or deselected.\nexport interface SelectAllAction { kind: typeof SelectAllAction.KIND select: boolean } Associated Command: SelectAllCommand\nGetSelectionAction A GetSelectionAction is used to request the server to send the client the current selection state.\nexport interface GetSelectionAction extends RequestAction\u0026lt;SelectionResult\u0026gt; { kind: typeof GetSelectionAction.KIND } Associated Command: GetSelectionCommand\nSelectionResult A SelectionResult is the response from a GetSelectionAction. It contains the selectedElementsIDs property, which holds the IDs of the selected elements.\nexport interface SelectionResult extends ResponseAction { kind: typeof SelectionResult.KIND selectedElementsIDs: string[] } CollapseExpandAction A CollapseExpandAction is sent from the client to the server to recalculate the diagram when the expansion state of elements change on the client side. The expandIds property holds the IDs of the elements that have been expanded, and the collapseIds property holds the IDs of the elements that have been collapsed.\nexport interface CollapseExpandAction { kind: typeof CollapseExpandAction.KIND expandIds: string[] collapseIds: string[] } CollapseExpandAllAction A CollapseExpandAllAction is used to collapse or expand all elements in the model. The expand property is used to specify whether the elements should be expanded or collapsed.\nexport interface CollapseExpandAllAction { kind: typeof CollapseExpandAllAction.KIND expand: boolean } OpenAction An OpenAction is triggered when the user double-clicks an element which has the openFeature enabled. What should happen when this action is fired is highly application-specific and should be implemented on a per-application basis. The elementId property holds the ID of the element that has been double-clicked.\nexport interface OpenAction { kind: typeof OpenAction.KIND elementId: string } LayoutAction A LayoutAction is used to trigger a layout calculation on the entire diagram or on a subset of elements.\nexport interface LayoutAction { kind: typeof LayoutAction.KIND layoutType?: string elementIds?: string[] } CenterAction A CenterAction is used to center the view on a set of elements. The elementIds property holds the IDs of the elements to center on. The animate property is used to specify whether the centering should be animated. The retainZoom property is used to specify whether the zoom level should be retained, otherwise the zoom level is reset to its initial value. The zoomScale property is used to specify the zoom level.\nIf elementIds is empty, the action centers on the entire diagram.\nexport interface CenterAction extends Action { kind: typeof CenterAction.KIND elementIds: string[] animate: boolean retainZoom: boolean zoomScale?: number } Associated Command: CenterCommand\nFitToScreenAction A FitToScreenAction is used to fit the selected set of elements to the current available drawing area. The elementIds property holds the IDs of the elements to fit to the screen. The padding property is used to specify the padding around the elements. The maxZoom property is used to specify the maximum zoom level. The animate property is used to specify whether the fit to screen should be animated.\nIf elementIds is empty, the action fits the entire diagram to the screen.\nexport interface FitToScreenAction extends Action { kind: typeof FitToScreenAction.KIND; elementIds: string[] padding?: number maxZoom?: number animate: boolean } Associated Command: FitToScreenCommand\nSetViewportAction A SetViewportAction is used to set the viewport scroll and zoom values of the diagram. The elementId property holds the ID of the viewport to manipulate (usually the root element). The newViewport property holds the new scroll and zoom values. The animate property is used to specify whether the centering should be animated.\nexport interface SetViewportAction extends Action { kind: typeof SetViewportAction.KIND; elementId: string newViewport: Viewport animate: boolean } Associated Command: SetViewportCommand\nGetViewportAction A GetViewportAction is used to request the current viewport scroll and zoom values, and canvas bounds.\nexport interface GetViewportAction extends RequestAction\u0026lt;ViewportResult\u0026gt; { kind: typeof GetViewportAction.KIND; } Associated Command: GetViewportCommand\nViewportResult A ViewportResult is the response from a GetViewportAction. It contains the viewport property, which holds the scroll and zoom values, and the canvasBounds property, which holds the canvas bounds.\nexport interface ViewportResult extends ResponseAction { kind: typeof ViewportResult.KIND; viewport: Viewport canvasBounds: Bounds } BringToFrontAction A BringToFrontAction is used to bring a set of elements to the front. The elementIDs property holds the IDs of the elements to bring to the front.\nSVG elements are rendered using the \u0026ldquo;painter algorithm\u0026rdquo; meaning that the rendering obeys the order of the elements in the DOM. This action manipulates the order of the elements in the DOM so that they are placed at the end and therefore rendered on top of other elements.\nexport interface BringToFrontAction extends Action { kind: typeof BringToFrontAction.KIND; elementIDs: string[] } UndoAction An UndoAction is used to undo the last operation on the stack of operations.\nexport interface UndoAction extends Action { kind: typeof UndoAction.KIND; } RedoAction A RedoAction is used to redo the last undone operation.\nexport interface RedoAction extends Action { kind: typeof RedoAction.KIND; } MoveAction A MoveAction is used to move a set of elements to new positions. The moves property holds the moves to be performed. The animate property is used to specify whether the moves should be animated. The finished property is used to specify whether the moves are finished. The stoppable property is used to specify whether the moves can be stopped.\nexport interface MoveAction extends Action { kind: typeof MoveAction.KIND moves: ElementMove[] animate: boolean finished: boolean stoppable: boolean } Associated Command: MoveCommand\nHoverFeedbackAction A HoverFeedbackAction is triggered when the mouse pointer hovers over an element. The mouseoverElement property holds the ID of the element the mouse is over, and the mouseIsOver property is used to specify whether the mouse is over the element.\nexport interface HoverFeedbackAction extends Action { kind: typeof HoverFeedbackAction.KIND mouseoverElement: string mouseIsOver: boolean } Associated Command: HoverFeedbackCommand\nCreateElementAction A CreateElementAction is used to create a new element in the model. The containerId property holds the ID of the container (a.k.a the parent element) in which the new element should be created, and the elementSchema property holds the schema of the new element.\nexport interface CreateElementAction extends Action { kind: typeof CreateElementAction.KIND containerId: string elementSchema: SModelElement } Associated Command: CreateElementCommand\nDeleteElementAction A DeleteElementAction is used to delete a set of elements from the model. The elementIds property holds the IDs of the elements to be deleted.\nexport interface DeleteElementAction extends Action { kind: typeof DeleteElementAction.KIND elementIds: string[] } Associated Command: DeleteElementCommand\nApplyLabelEditAction An ApplyLabelEditAction is used to apply a label edit to a label element. The labelId property holds the ID of the label to be edited, and the text property holds the new text for the label.\nexport interface ApplyLabelEditAction extends Action { kind: typeof ApplyLabelEditAction.KIND; labelId: string, text: string } Associated Command: ApplyLabelEditCommand\nReconnectAction A ReconnectAction is used to change the source and target of a routable element (e.g. edge). The routableId property holds the ID of the routable element, and the newSourceId and newTargetId properties hold the IDs of the new source and target elements.\nexport interface ReconnectAction extends Action { kind: typeof ReconnectAction.KIND routableId: string newSourceId?: string newTargetId?: string } Associated Command: ReconnectCommand\nInitializeCanvasBoundsAction An InitializeCanvasBoundsAction is used to set the initial bounds of the canvas. The newCanvasBounds property holds the new bounds for the canvas.\nexport interface InitializeCanvasBoundsAction extends Action { kind: typeof InitializeCanvasBoundsAction.KIND newCanvasBounds: Bounds } Associated Command: InitializeCanvasBoundsCommand\nSetUIExtensionVisibilityAction A SetUIExtensionVisibilityAction is used to set the visibility of a UI extension. The extensionId property holds the ID of the extension, and the visible property is used to specify whether the extension should be visible. The contextElementsId property holds the IDs of the elements that are subject to the action, for example the label target by an edit.\nexport interface SetUIExtensionVisibilityAction extends Action { kind: typeof SetUIExtensionVisibilityAction.KIND; extensionId: string visible: boolean contextElementsId: string[] } Associated Command: SetUIExtensionVisibilityCommand\nEditLabelAction An EditLabelAction is used to trigger the editing of a label. The labelId property holds the ID of the label to be edited.\nexport interface EditLabelAction extends Action { kind: typeof EditLabelAction.KIND labelId: string } SwitchEditModeAction A SwitchEditModeAction is used to switch the edit mode, for example when moving an edge routing handle. The elementsToActivate property holds the IDs of the elements to activate, and the elementsToDeactivate property holds the IDs of the elements to deactivate.\nexport interface SwitchEditModeAction extends Action { kind: typeof SwitchEditModeAction.KIND; elementsToActivate: string[] elementsToDeactivate: string[] } Associated Command: SwitchEditModeCommand\nAddRemoveBezierSegmentAction An AddRemoveBezierSegmentAction is used to add or remove a bezier segment from an edge. The targetId property holds the ID of the edge, and the actionTask property is used to specify whether the segment should be added or removed.\nexport interface AddRemoveBezierSegmentAction extends Action { kind: typeof AddRemoveBezierSegmentAction.KIND targetId: string actionTask: \u0026#39;add\u0026#39; | \u0026#39;remove\u0026#39; } Associated Command: AddRemoveBezierSegmentCommand\nCommitModelAction A CommitModelAction is used to commit the current model state to the model source. The SModel (internal model) contains transitional states such as intermediate move positions, added handles, etc. When a user interaction that spans multiple commands finishes, the CommitModelAction is fired to write the final state to the model source.\nexport interface CommitModelAction extends Action { kind: typeof CommitModelAction.KIND } Associated Command: CommitModelCommand\nRequestExportSvgAction A RequestExportSvgAction is used to request the server to export the diagram to an SVG string.\nexport interface RequestExportSvgAction extends RequestAction\u0026lt;ExportSvgAction\u0026gt; { kind: typeof RequestExportSvgAction.KIND } Associated Command: ExportSvgCommand\nExportSvgAction An ExportSvgAction is used to send the SVG string of the exported diagram as a response to a RequestExportSvgAction.\nexport interface ExportSvgAction extends ResponseAction { kind: typeof ExportSvgAction.KIND svg: string } ","description":"Action RequestAction ResponseAction RejectAction RequestModelAction SetModelAction UpdateModelAction SetPopupModelAction SetBoundsAction RequestBoundsAction ComputedBoundsAction LoggingAction SelectAction SelectAllAction GetSelectionAction SelectionResult CollapseExpandAction CollapseExpandAllAction OpenAction LayoutAction CenterAction FitToScreenAction SetViewportAction GetViewportAction ViewportResult BringToFrontAction UndoAction RedoAction MoveAction HoverFeedbackAction CreateElementAction DeleteElementAction ApplyLabelEditAction ReconnectAction InitializeCanvasBoundsAction SetUIExtensionVisibilityAction EditLabelAction SwitchEditModeAction AddRemoveBezierSegmentAction CommitModelAction RequestExportSvgAction ExportSvgAction Action An Action represents an interaction with the diagram. It is a plain data structure and is transferable between the client and the server. It holds information about the type of action in the kind property, which is a unique string identifier for the action type."},{"id":1,"href":"/docs/communication-with-actions/","title":"Communication with Actions","parent":"Docs","content":" Actions Action RequestAction ResponseAction Commands ModelSource ActionDispatcher Action Flow RequestAction Flow Interactions between the client and server are based on an event-based protocol. Sprotty makes a distinction between two types of events: Actions and Commands. Actions are used to communicate between the client and the server, while commands are used to apply changes to the diagram on the client side.\nActions Actions are used to communicate between the client and the server in a bidirectional manner. They are plain JSON serializable objects so that they can easily be passed through all kinds of APIs. They can be distinguished through their KIND string property. For a list of available actions, see this reference page\nWe can further distinguish between three types of actions:\nAction This is a \u0026ldquo;fire and forget\u0026rdquo; event. It is sent from the client to the server, or vice versa, to notify the other side of a certain event. The other side can react to this event, but it does not need to send a response.\nexport interface MyAction extends Action { kind: typeof MyAction.KIND } export namespace MyAction { export const KIND = \u0026#39;my-action\u0026#39; export function create(): MyAction { return { kind: KIND } } } // for dispatching the action dispatcher.dispatch(MyAction.create()) // or dispatcher.dispatch({ kind: MyAction.KIND }) RequestAction This type of action is sent to request a certain piece of information. The other side is expected to respond with a ResponseAction.\nexport interface MyRequestAction extends RequestAction { kind: typeof MyRequestAction.KIND } export namespace MyRequestAction { export const KIND = \u0026#39;my-request-action\u0026#39; export function create(): MyRequestAction { return { kind: KIND } } } // for dispatching the action const response = dispatcher.request\u0026lt;MyResponseAction\u0026gt;(MyRequestAction.create()) // or const response = dispatcher.request({ kind: MyRequestAction.KIND }) ResponseAction This type of action is sent as a response to a RequestAction. It contains the requested information.\nexport interface MyResponseAction extends ResponseAction { kind: typeof MyResponseAction.KIND } export namespace MyResponseAction { export const KIND = \u0026#39;my-response-action\u0026#39; export function create(): MyResponseAction { return { kind: KIND } } } Commands Commands are used to apply changes to the diagram on the client side. They are triggered by their associated action.\nexport class MyCommand extends Command { static KIND = \u0026#39;my-command\u0026#39; constructor(@inject(TYPES.Action) protected readonly action: MyAction) { super() } execute(context: CommandExecutionContext): CommandReturn { // apply changes to the diagram } undo(context: CommandExecutionContext): CommandReturn { // revert changes to the diagram } redo(context: CommandExecutionContext): CommandReturn { // re-apply changes to the diagram } // A `CommandReturn` is a SModelRootImpl, or a Promise\u0026lt;SModelRootImpl\u0026gt;, or a `CommandResult`(i.e. { model: SModelRootImpl, modelChanged: boolean, cause?: Action }) } Commands need to be registered in the dependency injection container.\nconst myContainer = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { ... const context = { bind, isBound } configureCommand(context, MyCommand) }) ModelSource A ModelSource is responsible for handling actions. A local ModelSource is used to handle actions on the client side, while a remote ModelSource is used to handle actions on the server side.\nEvery action that the designated ModelSource is supposed to handle needs to be registered inside the initialize method, and the method containing the logic for handling the action needs to be implemented in the ModelSource and selected via a switch in the handle method.\n// the class can extend LocalModelSource, DiagramServerProxy, or any derivative of ModelSource export class MyModelSource extends LocalModelSource { initialize(registry: ActionHandlerRegistry): void { super.initialize(registry) registry.register(MyAction.KIND, this) } handle(action: Action): void { switch (action.kind) { case MyAction.KIND: this.handleMyAction(action as MyAction) break default: super.handle(action) } } protected handleMyAction(action: MyAction): void { // handle the action } } ActionDispatcher The ActionDispatcher collects actions, converts them to command if necessary, and dispatches them to their respective handlers.\nexport class ActionDispatcher implements IActionDispatcher { // dispatch a single action dispatch(action: Action): Promise\u0026lt;void\u0026gt; { ... } // dispatch multiple actions dispatchAll(actions: Action[]): Promise\u0026lt;void\u0026gt; { ... } // dispatch a RequestAction request\u0026lt;Res extends ResponseAction\u0026gt;(action: RequestAction\u0026lt;Res\u0026gt;): Promise\u0026lt;Res\u0026gt; { ... } } Action Flow An action (i.e. \u0026ldquo;fire and forget\u0026rdquo; event) is sent to the action dispatcher. The action dispatcher then dispatches the action to its respective handler. The handler can then react to the action and a Command may or may not be triggered on the client. Here we will look at how an Action sent from the Client is handled by the ActionDispatcher and its respective ActionHandler on the server side:\nsequenceDiagram participant C as Client participant AD as ActionDispatcher participant AH as ActionHandler C -\u003e\u003e AD: An Action is sent to the ActionDispatcher AD -\u003e\u003e AH: The Action is forwarded to the corresponding ActionHandler AH --\u003e\u003e C: The Action may trigger a Command This is the simplest scenario. In reality, the ActionHandler may also send another Action to the ActionDispatcher, creating an Action chain. In most cases, the ActionHandler will apply some changes to the model and then send another action to update the model on the client side.\nRequestAction Flow A RequestAction is sent from the client to the server. The server is expected to produce a ResponseAction as a response to the RequestAction. Here we will look at how a RequestAction sent from the Client is handled by the ActionDispatcher and its respective handler on the server side:\nsequenceDiagram participant C as Client participant AD as ActionDispatcher participant RAH as RequestActionHandler participant RespAH as ResponseActionHandler C -\u003e\u003e AD: A RequestAction is sent AD -\u003e\u003e RAH: The RequestAction is forwarded to the corresponding ActionHandler RAH -\u003e\u003e AD: A ResponseAction is sent AD -\u003e\u003e RespAH: The ResponseAction is forwarded to the corresponding ActionHandler RespAH --\u003e\u003e C: The Action may trigger a Command ","description":"Actions Action RequestAction ResponseAction Commands ModelSource ActionDispatcher Action Flow RequestAction Flow Interactions between the client and server are based on an event-based protocol. Sprotty makes a distinction between two types of events: Actions and Commands. Actions are used to communicate between the client and the server, while commands are used to apply changes to the diagram on the client side.\nActions Actions are used to communicate between the client and the server in a bidirectional manner."},{"id":2,"href":"/docs/custom-interactions/","title":"Creating Custom Interaction","parent":"Docs","content":" Buttons and Button Handlers Mouse and Keyboard Listeners Projection Bars Buttons and Button Handlers Buttons in Sprotty work similarly to the other model elements, but they enable you to directly hook up handlers that react to the push of a button. As in the other examples with other types of nodes, we first need to define the model and view class and define its type ID. in addition, we also need to define a button handler of type IButtonHandler.\nconst container = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { const context = { bind, unbind, isBound, rebind }; configureModelElement(context, \u0026#39;graph\u0026#39;, SGraph, SGraphView); configureModelElement(context, \u0026#39;button:custom\u0026#39;, SButton, CustomButtonView); configureButtonHandler({bind, isBound}, \u0026#39;button:custom\u0026#39;, CustomButtonHandler); configureViewerOptions(context, { needsClientLayout: true, baseDiv: \u0026#39;sprotty\u0026#39; }); }); A button handler is a simple injectable class with a buttonPressed(button: SButton): Action[] method. The actions that this method returns are passed to the ActionDispatcher to be handled there.\n@injectable() export class CustomButtonHandler implements IButtonHandler { buttonPressed(button: SButton): Action[] { alert(\u0026#39;button on\u0026#39; + button.parent.id + \u0026#39; pressed\u0026#39;); return []; } } Mouse and Keyboard Listeners Sprotty also offers the ability to attach mouse and keyboard listeners by registering MouseListener or KeyListener. This can be simply done by binding the custom listener to the respective listener type in your DI-container like this:\nbind(CustomMouseListener).toSelf().inSingletonScope(); bind(TYPES.MouseListener).toService(CustomMouseListener); These listeners are global, meaning they react to every interaction with the diagram. A very simple mouse Listener would look like this:\nexport class CustomMouseListener extends MouseListener { doubleClick(target: SModelElementImpl, event: MouseEvent): (Action | Promise\u0026lt;Action\u0026gt;)[] { alert(\u0026#39;double clicked \u0026#39; + target.id) return []; } } If only specific types of nodes are supposed to be interacted with through this custom listener, it\u0026rsquo;s recommended to create a custom feature.\nProjection Bars Another interactive Sprotty feature is the ProjectedViewportView. This view automatically adds a vertical and horizontal scrollbar to our diagram view in which our current viewport is shown, like in the following image.\nTo activate this feature, instead of using SGraphImpl and SGraphView for our root element, as we did in the other examples, we use ViewportRootElement and ProjectedViewportView. The scrollbars created through ProjectedViewportView can be styled via the .sprotty-viewport and .sprotty-projection-bar CSS classes.\nAs we can see in the image, these scrollbars can contain projections of our nodes, which show their horizontal and vertical position. Double-clicking on a projection will center the view on the node the projection belongs to.\nTo add projections we add the Projectable type to the nodes in our model schema like this:\n\u0026lt;SNode \u0026amp; Projectable\u0026gt;{ id: \u0026#39;svg\u0026#39;, type: \u0026#39;node:svg\u0026#39;, text: \u0026#39;\u0026#39;, projectionCssClasses: [\u0026#39;svg-projection\u0026#39;] } The Projectable interface requires us to specify the projectionCssClasses property, which defines the CSS classes the framework will apply to the HTML div element that represents the projection in the projection bar. If no projectionCssClasses property value is specified, no projection will be created. As projections are simple HTML div elements positioned on the projection bar, they can easily be styled as follows:\n.svg-projection { background-color: rgba(255, 153, 0, 0.5); } ","description":"Buttons and Button Handlers Mouse and Keyboard Listeners Projection Bars Buttons and Button Handlers Buttons in Sprotty work similarly to the other model elements, but they enable you to directly hook up handlers that react to the push of a button. As in the other examples with other types of nodes, we first need to define the model and view class and define its type ID. in addition, we also need to define a button handler of type IButtonHandler."},{"id":3,"href":"/docs/","title":"Docs","parent":"Sprotty","content":"","description":""},{"id":4,"href":"/docs/features/","title":"Features","parent":"Docs","content":" alignFeature boundsFeature connectableFeature creatingOnDragFeature decorationFeature deletableFeature edgeLayoutFeature editFeature editLabelFeature expandFeature exportFeature fadeFeature hoverFeedbackFeature layoutableChildFeature layoutContainerFeature moveFeature nameFeature openFeature popupFeature selectFeature viewportFeature withEditLabelFeature Features can be viewed as a set of functionalities that a given element can support. They can enrich the behavior and usability of the diagram model.\nSModelElements can have default features that will apply to all model elements that are instance of this SModelElement.Default features are specified in the DEFAULT_FEATURES field, which can be overridden in inherited classes. This way, the default features will be enabled for all instances of the class.\nLet\u0026rsquo;s have a look at the SNodeImpl class and how it implements default features:\nexport class SNodeImpl extends SConnectableElementImpl implements Selectable, Fadeable, Hoverable { static readonly DEFAULT_FEATURES = [connectableFeature, deletableFeature, selectFeature, boundsFeature, moveFeature, layoutContainerFeature, fadeFeature, hoverFeedbackFeature, popupFeature]; ... } It is possible to fine-tune the behavior in the dependency injection container by enabling or disabling features for a given model element type.\nconfigureElement(\u0026#39;my-node-type\u0026#39;, SNodeImpl, RectangularNodeView, {enable: [layoutableChildFeature], disable: [moveFeature]}) To ensure that the required additional properties are present on the model element, Sprotty comes with a set of interfaces to ensure correct implementation in the model element class. These interfaces must extend SModelExtension.\nalignFeature Controls the position adjustment of an element. It is given by the alignment: Point property of an element. It applies a translate to the svg element. This translation is applied in addition to the translation that may be applied by the layout engine.\nInterface: Alignable\nexport interface Alignable extends SModelExtension { alignment: Point } boundsFeature Controls if the bounds of an element can be calculated and updated. The element needs a position and size.\nInterface: BoundsAware\nexport interface BoundsAware extends SModelExtension{ bounds: Bounds } connectableFeature Controls if an element can be connected to other elements. To be connectable, the element must be an SRoutableElementImpl and have a role of source or target.\nInterface: Connectable\nexport interface Connectable extends SModelExtension{ canConnect(routable: SRoutableElementImpl, role: \u0026#39;source\u0026#39; | \u0026#39;target\u0026#39;): boolean } creatingOnDragFeature Controls if an element is created on drag. The element needs to implement a createAction method that returns an Action that creates the element.\nInterface: CreatingOnDrag\nexport interface CreatingOnDrag extends SModelExtension { createAction(id: string): Action } decorationFeature Controls if an element is a decoration. It is generally used to show error or warning markers on model elements.\nInterface: Decoration\nexport interface Decoration extends SModelExtension {} deletableFeature Controls if an element can be deleted from the diagram. To be deletable, an element needs to be an SChildElementImpl.\nInterface: Deletable\nexport interface Deletable extends SModelExtension {} edgeLayoutFeature Controls if an element is layoutable on an edge. The element must be an SChildElementImpl, its parent must be an SRoutableElementImpl, the element must have the edgePlacement property, and must have the boundsFeature. This is commonly used for labels that are displayed on an edge.\nedgePlacement: { position: number, // between 0 and 1, from the source (0) to the target (1) side: \u0026#39;bottom\u0026#39; | \u0026#39;top\u0026#39; | \u0026#39;left\u0026#39; | \u0026#39;right\u0026#39; | \u0026#39;on\u0026#39;, rotate: boolean, offset: number, moveMode: \u0026#39;edge\u0026#39; | \u0026#39;free\u0026#39; | \u0026#39;none\u0026#39; } Interface: EdgeLayoutable\nexport interface EdgeLayoutable extends SModelExtension { edgePlacement: EdgePlacement } editFeature Controls if an edge routing can be edited. The edge must be an SRoutableElementImpl.\neditLabelFeature Controls if a label can be edited. The label must have the text property.\nInterface: EditableLabel\nexport interface EditableLabel extends SModelExtension { text: string readonly isMultiline?: boolean readonly editControlDimension?: Dimension readonly editControlPositionCorrection?: Point } expandFeature Controls if an element can be expanded. The element must have the property expanded.\nInterface: Expandable\nexport interface Expandable extends SModelExtension { expanded: boolean } exportFeature Controls if an element can be exported. It is enabled by default to the ViewportRootElement making the entire diagram exportable.\nfadeFeature Controls if an element can change its opacity. The element must have the opacity property.\nInterface: Fadeable\nexport interface Fadeable extends SModelExtension { opacity: number } hoverFeedbackFeature Controls if the element can show hover feedback. The element must have the hoverFeedback property.\nInterface: Hoverable\nexport interface Hoverable extends SModelExtension { hoverFeedback: boolean } layoutableChildFeature Controls if an element obeys its parent\u0026rsquo;s layout options. The element must use the boundsFeature.\nInterface: LayoutableChild\nexport interface LayoutableChild extends SModelExtension, BoundsAware { layoutOptions?: ModelLayoutOptions } layoutContainerFeature Controls if an element can layout its children. The element must have the layout property.\nInterface: LayoutContainer\nexport interface LayoutContainer extends LayoutableChild { layout: string } moveFeature Controls if an element is moveable. The element must have the position property.\nInterface: Locateable\nexport interface Locateable extends SModelExtension { position: Point } nameFeature Controls if an element has a name. This feature is used during renaming to change the name attribute on the model element.\nInterface: Nameable\nexport interface Nameable extends SModelExtension { name: string } openFeature Controls if an element can be opened.\npopupFeature Controls if an element display a popup on hover.\nselectFeature Controls if an element can be selected. When an element is selected, its selected property is set to true.\nInterface: Selectable\nexport interface Selectable extends SModelExtension { selected: boolean } viewportFeature Controls if an element is a viewport. The element must be a SModelRootImpl and have the zoom and scroll properties.\nwithEditLabelFeature Controls if an element has an editable label. The element must have the editableLabel property.\nInterface: WithEditableLabel\nexport interface WithEditableLabel extends SModelExtension { readonly editableLabel?: EditableLabel \u0026amp; SModelElementImpl; } ","description":"alignFeature boundsFeature connectableFeature creatingOnDragFeature decorationFeature deletableFeature edgeLayoutFeature editFeature editLabelFeature expandFeature exportFeature fadeFeature hoverFeedbackFeature layoutableChildFeature layoutContainerFeature moveFeature nameFeature openFeature popupFeature selectFeature viewportFeature withEditLabelFeature Features can be viewed as a set of functionalities that a given element can support. They can enrich the behavior and usability of the diagram model.\nSModelElements can have default features that will apply to all model elements that are instance of this SModelElement.Default features are specified in the DEFAULT_FEATURES field, which can be overridden in inherited classes."},{"id":5,"href":"/docs/getting-started/","title":"Getting Started","parent":"Docs","content":"Our \u0026lsquo;Getting Started\u0026rsquo; example consists of a simple application that displays a list of tasks, their status, and the relationship between them in a HTML page.\nThe main steps to integrate Sprotty into our application are as follows:\nSet-up your application. Define your model by creating sub-interfaces of SModelElement. Implement views to generate SVGs for each type of model element. Configure the diagram through dependency injection. Connect to a model source, either local or remote Fast-Forward With Yeoman If you\u0026rsquo;d like to skip the manual steps below and create a Sprotty-based project right away, you can use the Yeoman generator:\nnpm install -g yo generator-sprotty yo sprotty Answer a few questions and you\u0026rsquo;ll get a ready-to-use example project.\nSetting-up Our Application Our example application is based on TypeScript. In this application we will set up our project to be ready for receiving Sprotty.\nCreate a new directory and navigate to it\nInitialize the project by running\nnpm init -y This will create a package.json file.\nModify package.json to add a build script and necessary dependencies\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;esbuild ./index.ts --bundle --sourcemap --outfile=./out/index.js\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;esbuild\u0026#34;: \u0026#34;^0.17.8\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.9.5\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;reflect-metadata\u0026#34;: \u0026#34;^0.1.13\u0026#34;, \u0026#34;sprotty\u0026#34;: \u0026#34;^1.0.0\u0026#34; } } Install dependencies running npm i\nInitialize the TypeScript project\nnpx tsc --init This will create tsconfig.json file at the root of your project. You should overwrite this files with the following:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json.schemastore.org/tsconfig\u0026#34;, \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;ES2019\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;sourceMap\u0026#34;: true, \u0026#34;experimentalDecorators\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;react\u0026#34;, \u0026#34;types\u0026#34;: [ \u0026#34;reflect-metadata\u0026#34; ] }, \u0026#34;lib\u0026#34;: [ \u0026#34;ES2019\u0026#34;, \u0026#34;DOM\u0026#34; ] } Create a index.html file at the root of your project\n\u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;./out/index.js\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;sprotty-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; Add some default CSS styles by creating a styles.css file at the root of the project:\n.sprotty-graph { width: 100%; height: 100%; } .sprotty-edge { fill: none; stroke: black; stroke-width: 1px; } Our project is now set-up and ready for integrating Sprotty diagrams.\nDefine Your Model Sprotty comes with a set of model classes that you can reuse for your application. e.g. SNodeImpl and SEdgeImpl for graphs and SChildElementImpl for other views. However, it is often necessary to add application-specific properties to model elements, so their graphical views can be parameterized.\nWe will define a new interface for our nodes called TaskNode, extending Sprotty\u0026rsquo;s SNode interface with application-specific properties. Create a new file models.ts at the root of the project:\nimport { SNode } from \u0026#34;sprotty-protocol\u0026#34; export interface TaskNode extends SNode { name: string; isRunning: boolean; isFinished: boolean; } Implement Views A view maps a model element to its graphical representation. You can create your own views by creating a class implementing IView or extending a view already available in Sprotty.\nIn the following example we use the JSX syntax to create a SVG group with a rect and a text element. Add a new file views.tsx (note the tsx extension) at the root of the project:\n/** @jsx svg */ import { svg } from \u0026#39;sprotty/lib/lib/jsx\u0026#39;; import { injectable } from \u0026#39;inversify\u0026#39;; import { VNode } from \u0026#39;snabbdom\u0026#39;; import { IView, RenderingContext, SNode } from \u0026#39;sprotty\u0026#39;; import { TaskNode } from \u0026#39;./models\u0026#39;; @injectable() export class TaskNodeView implements IView { render(node: Readonly\u0026lt;SNode \u0026amp; TaskNode\u0026gt;, context: RenderingContext): VNode { const position = 50; return \u0026lt;g\u0026gt; \u0026lt;rect class-sprotty-node={true} class-task={true} class-running={node.isRunning} class-finished={node.isFinished} width={node.size.width} height={node.size.height} \u0026gt; \u0026lt;/rect\u0026gt; \u0026lt;text x={position} y={position + 5}\u0026gt;{node.name}\u0026lt;/text\u0026gt; \u0026lt;/g\u0026gt;; } } The SVG elements are styled with CSS using classes that are injected using the class-myClass={boolean expression} in the jsx expression. Add the following to styles.css:\n.sprotty-node.task { fill: #c0e0fc; stroke: #444; stroke-width: 1; } .sprotty-node.task.running { fill: #f00; } .sprotty-node.task.finished { fill: #0f0; } text { stroke-width: 0; stroke: #000; fill: #000; font-family: sans-serif; font-size: 10pt; text-anchor: middle; } Configure the Diagram The configuration of our Sprotty application is done via Dependency Injection using InversifyJS. We recommend defining your InversifyJS container in a file named di.config.ts at the root of the project which could look like this:\nimport { Container, ContainerModule } from \u0026#39;inversify\u0026#39;; import { configureModelElement, configureViewerOptions, loadDefaultModules, LocalModelSource, PolylineEdgeView, SEdgeImpl, SGraphImpl, SGraphView, SNodeImpl, TYPES } from \u0026#39;sprotty\u0026#39;; import { TaskNodeView } from \u0026#39;./views\u0026#39;; export const createContainer = (containerId: string) =\u0026gt; { const myModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { bind(TYPES.ModelSource).to(LocalModelSource).inSingletonScope(); const context = { bind, unbind, isBound, rebind }; configureModelElement(context, \u0026#39;graph\u0026#39;, SGraphImpl, SGraphView); configureModelElement(context, \u0026#39;task\u0026#39;, SNodeImpl, TaskNodeView); configureModelElement(context, \u0026#39;edge\u0026#39;, SEdgeImpl, PolylineEdgeView); configureViewerOptions(context, { needsClientLayout: false, baseDiv: containerId }); }); const container = new Container(); loadDefaultModules(container); container.load(myModule); return container; }; Views are registered using configureModelElement which takes a context, a type, an element class, and a view. loadDefaultModules is used to include Sprotty\u0026rsquo;s default modules, while container.load can be used to include extra modules required by our application.\nConnect to a Model Source Sprotty supports two kinds of model sources:\nLocalModelSource allows to create models directly in TypeScript or JavaScript WebSocketDiagramServer delegates to a remote source that is connected via a web socket In this example, we consider the local variant. To enable the model source, we add the following line to our module definition (see previous section):\nbind(TYPES.ModelSource).to(LocalModelSource).inSingletonScope() Afterwards you can use the LocalModelSource to initialize and update the model. For example, the following graph consists of three task nodes with a connection between the first two. Create a new file model-source.ts at the root of the project:\nimport { SGraph, SEdge, SNode } from \u0026#34;sprotty-protocol\u0026#34;; import { TaskNode } from \u0026#34;./models\u0026#34;; export const graph: SGraph = { type: \u0026#39;graph\u0026#39;, id: \u0026#39;graph\u0026#39;, children: [ \u0026lt;SNode \u0026amp; TaskNode\u0026gt;{ type: \u0026#39;task\u0026#39;, id: \u0026#39;task01\u0026#39;, name: \u0026#39;First Task\u0026#39;, isFinished: true, isRunning: false, position: { x: 0, y: 0 }, size: { width: 100, height: 100 } }, \u0026lt;SNode \u0026amp; TaskNode\u0026gt;{ type: \u0026#39;task\u0026#39;, id: \u0026#39;task02\u0026#39;, name: \u0026#39;Second Task\u0026#39;, isFinished: false, isRunning: true, position: { x: 0, y: 200 }, size: { width: 100, height: 100 } }, \u0026lt;SNode \u0026amp; TaskNode\u0026gt;{ type: \u0026#39;task\u0026#39;, id: \u0026#39;task03\u0026#39;, name: \u0026#39;Third Task\u0026#39;, isFinished: false, isRunning: false, position: { x: 150, y: 0 }, size: { width: 100, height: 100 } }, \u0026lt;SEdge\u0026gt;{ type: \u0026#39;edge\u0026#39;, id: \u0026#39;edge01\u0026#39;, sourceId: \u0026#39;task01\u0026#39;, targetId: \u0026#39;task02\u0026#39;, routerKind: \u0026#39;manhattan\u0026#39;, } ] }; Finally, we need to create the entry point of our application in an index.ts file:\nimport \u0026#34;reflect-metadata\u0026#34;; import { LocalModelSource, TYPES } from \u0026#39;sprotty\u0026#39;; import { createContainer } from \u0026#39;./di.config\u0026#39;; import { graph } from \u0026#39;./model-source\u0026#39;; export default function run() { const container = createContainer(\u0026#34;sprotty-container\u0026#34;); const modelSource = container.get\u0026lt;LocalModelSource\u0026gt;(TYPES.ModelSource); modelSource.setModel(graph); } document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; run()); That\u0026rsquo;s it! Run npm run build and open your HTML file, you should see the following diagram! There is some level of interactivity by default, try it out! Select nodes by clicking on them and move them around by dragging, adjust the zoom-level with the mouse wheel, navigate the diagram by panning via left-click and drag outside of a node. ","description":"Our \u0026lsquo;Getting Started\u0026rsquo; example consists of a simple application that displays a list of tasks, their status, and the relationship between them in a HTML page.\nThe main steps to integrate Sprotty into our application are as follows:\nSet-up your application. Define your model by creating sub-interfaces of SModelElement. Implement views to generate SVGs for each type of model element. Configure the diagram through dependency injection. Connect to a model source, either local or remote Fast-Forward With Yeoman If you\u0026rsquo;d like to skip the manual steps below and create a Sprotty-based project right away, you can use the Yeoman generator:"},{"id":6,"href":"/docs/introduction/","title":"Introduction","parent":"Docs","content":"Sprotty is a next-generation, open-source diagramming framework built with web-technologies.\nSome selected features:\nFast, scalable SVG rendering that is compatible with all modern browsers and stylable with CSS Animations built into the core Support for a distributed runtime with client and server Fast, reactive client architecture implemented in TypeScript Java or Node.js based server architecture Configuration via dependency injection Integrations with Xtext, Langium, the Language Server Protocol, VS Code and Theia Can be run as a rich-client as well as in the browser Where to start? If you are new with Sprotty, we recommend taking a look at our Getting Started section before diving further.\nWant to contribute? Visit the Sprotty repository and have a look at the contribution guidelines to take part in Sprotty\u0026rsquo;s development.\n","description":"Sprotty is a next-generation, open-source diagramming framework built with web-technologies.\nSome selected features:\nFast, scalable SVG rendering that is compatible with all modern browsers and stylable with CSS Animations built into the core Support for a distributed runtime with client and server Fast, reactive client architecture implemented in TypeScript Java or Node.js based server architecture Configuration via dependency injection Integrations with Xtext, Langium, the Language Server Protocol, VS Code and Theia Can be run as a rich-client as well as in the browser Where to start?"},{"id":7,"href":"/docs/micro-layout/","title":"Micro-layout","parent":"Docs","content":" Layout Configuration Layout Options Alignment Padding Size Using SCompartments for Complex Layouts Layouting Nested Nodes The micro-layout refers to the layout of elements inside of a node, i.e. the layout of nested labels, buttons, etc. It is not to be confused with the macro-layout which refers to the layout of the entire graph, e.g. the position of nodes.\nLayout Configuration Any model element that implements or extends the SNode or SCompartment interface has an optional property layout that specifies the general layout of its children elements. Sprotty implements three layout configurations by default:\nstack: children elements are stacked on top of each other (default layout) hbox: children elements are arranged horizontally vbox: children elements are arranged vertically The layout property aims at arranging children elements that do not have a meaning in terms of graph hierarchy (i.e. labels, buttons, \u0026hellip;). Please note that children that are instances of SNodeImpl do not respect the layout property by default (more on that later).\nFirst and foremost, the micro-layout engine needs to be activated in the inversify container. This is done by setting the needsClientLayout property to true in the inversify container configuration:\nconst module = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { const context = {bind, unbind, isBound, rebind}; ... configureViewerOptions(context, { needsClientLayout: true }) }) Let\u0026rsquo;s now have a look at the following graph containing 3 nodes with 3 label children, each with a different layout configuration:\nexport const graph: SGraph = { type: \u0026#39;graph\u0026#39;, id: \u0026#39;graph\u0026#39;, children: [ // this node is using a \u0026#39;vbox\u0026#39; layout \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node01\u0026#39;, layout: \u0026#39;vbox\u0026#39;, children: [ \u0026lt;SLabel\u0026gt; { id: \u0026#39;label01-1\u0026#39;, text: \u0026#39;I am using a\u0026#39;, type: \u0026#39;label\u0026#39;, }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label01-2\u0026#39;, text: \u0026#39;vbox\u0026#39;, type: \u0026#39;label\u0026#39;, cssClasses: [\u0026#39;layout-label\u0026#39;] }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label01-3\u0026#39;, text: \u0026#39;layout\u0026#39;, type: \u0026#39;label\u0026#39;, }, ] }, // this node is using a \u0026#39;hbox\u0026#39; layout \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node02\u0026#39;, layout: \u0026#39;hbox\u0026#39;, position: { x: 100, y: 0 }, children: [ \u0026lt;SLabel\u0026gt; { id: \u0026#39;label02-1\u0026#39;, text: \u0026#39;I am using a\u0026#39;, type: \u0026#39;label\u0026#39;, }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label02-2\u0026#39;, text: \u0026#39;hbox\u0026#39;, type: \u0026#39;label\u0026#39;, cssClasses: [\u0026#39;layout-label\u0026#39;] }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label02-3\u0026#39;, text: \u0026#39;layout\u0026#39;, type: \u0026#39;label\u0026#39;, }, ] }, // this node is using a \u0026#39;stack\u0026#39; layout \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node03\u0026#39;, layout: \u0026#39;stack\u0026#39;, position: { x: 265, y: 0 }, children: [ \u0026lt;SLabel\u0026gt; { id: \u0026#39;label03-1\u0026#39;, text: \u0026#39;I am using a\u0026#39;, type: \u0026#39;label\u0026#39;, }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label03-2\u0026#39;, text: \u0026#39;stack\u0026#39;, type: \u0026#39;label\u0026#39;, cssClasses: [\u0026#39;layout-label\u0026#39;] }, \u0026lt;SLabel\u0026gt; { id: \u0026#39;label03-3\u0026#39;, text: \u0026#39;layout\u0026#39;, type: \u0026#39;label\u0026#39;, }, ] }, ] }; This results in the following visuals:\nIf you want different layout configurations, you can implement your own micro-layout engine and inject it via Dependency Injection.\nLayout Options It is possible to fine-tune the micro-layout by using the property layoutOptions.\n\u0026lt;SNode\u0026gt; { ... layout: \u0026#39;vbox\u0026#39;, layoutOptions: { ... } } Alignment You can control how children are aligned with the following properties:\nhAlign: 'left' | 'center' | 'right' for the horizontal alignment (not available for layout hbox) vAlign: 'top' | 'center' | 'bottom' for the vertical alignment (not available for layout vbox) Padding Spacing between the container and its children is controlled by the following properties:\npaddingTop: number for the padding at the top of the container (in pixels) paddingRight: number for the padding at the right of the container (in pixels) paddingBottom: number for the padding at the bottom of the container (in pixels) paddingLeft: number for the padding at left top of the container (in pixels) paddingFactor: number to define a factor for the padding depending on the size of the container Size The micro-layout engine takes care of computing the size of a container depending on the size and position of its children. This can lead to unesthetic results, if for example the size of labels differs greatly between nodes. To deal with these issues, you can configure the following properties:\nminWidth: number to set the minimal width of a container (in pixels) minHeight: number to set the minimal height of a container (in pixels) resizeContainer: boolean to indicate if the size of a container is dependent on the size of its children The position of the children elements (given as x-y coordinates) is always relative to their parents. This means that to position a child element for example at the top left corner of its parent, you need to set its position to {x: 0, y: 0}.\nUsing SCompartments for Complex Layouts SCompartments are used to group SModelElements and apply a given layout to this group. This allows for creating complex layouts inside of a node.\nFor clarity and illustration purpose, the SCompartments in the following diagram have a red outline, but you usually would not want to display it. Sprotty comes with a SCompartmentView that creates only a g element grouping its nested element. The g element does not result in any shape and is used only for grouping purposes.\nThe following code snippet shows how to organize your model elements by including SCompartments to achieve the layout shown above:\nexport const graph: SGraph = { type: \u0026#39;graph\u0026#39;, id: \u0026#39;graph\u0026#39;, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node01\u0026#39;, layout: \u0026#39;vbox\u0026#39;, children: [ \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp01\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;hbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node02\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node03\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp02\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;vbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node04\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node05\u0026#39;, size: { width: 25, height: 25 }, }, ] } ] }, \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp05\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;hbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp03\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;vbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node06\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node07\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp04\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;hbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node08\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node09\u0026#39;, size: { width: 25, height: 25 }, }, ] } ] }, \u0026lt;SCompartment\u0026gt;{ type: \u0026#39;comp\u0026#39;, id: \u0026#39;comp06\u0026#39;, cssClasses: [\u0026#39;red-outline\u0026#39;], layout: \u0026#39;vbox\u0026#39;, layoutOptions: { paddingTop: 5, paddingBottom: 5, paddingLeft: 5, paddingRight: 5, }, children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node10\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node11\u0026#39;, size: { width: 25, height: 25 }, }, \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;node12\u0026#39;, size: { width: 25, height: 25 }, }, ] } ] } ] },] }; Layouting Nested Nodes By design, nested SNode do not obey the layout property of an SNode parent. This is because nested nodes are usually used to represent a graph hierarchy, and the layout of the children of a node is not relevant for the structure of the graph. In general, the position of those nodes should be the responsibility of the macro-layout engine.\nHowever, if you still need the micro-layout engine to control the position of nested nodes, this can be achieved by enabling the layoutableChildFeature in the inversify container.\nconfigureModelElement(context, \u0026#39;your node type\u0026#39;, SNodeImpl, YourNodeView, {enable: [layoutableChildFeature]}) ","description":"Layout Configuration Layout Options Alignment Padding Size Using SCompartments for Complex Layouts Layouting Nested Nodes The micro-layout refers to the layout of elements inside of a node, i.e. the layout of nested labels, buttons, etc. It is not to be confused with the macro-layout which refers to the layout of the entire graph, e.g. the position of nodes.\nLayout Configuration Any model element that implements or extends the SNode or SCompartment interface has an optional property layout that specifies the general layout of its children elements."},{"id":8,"href":"/docs/model-sources/","title":"Model Sources","parent":"Docs","content":" General usage Local Model Source Diagram Server Creating a Custom Model Source Proxy When drawing a diagram with Sprotty we need a place to define and update the schema of the diagram to draw. Sprotty uses model sources to do this. Sprotty currently offers two different model sources: The LocalModelSource for local models and the DiagramServer for remote ones. flowchart TD; ActionDispatcher ModelSource LocalModelSource DiagramServerProxy DiagramServer ActionDispatcher \u003c-.-\u003e|Action| ModelSource ModelSource --- LocalModelSource ModelSource --- DiagramServerProxy DiagramServerProxy \u003c-.-\u003e|Action| DiagramServer Regardless of where your model-source is located, Sprotty handles them in a similar fashion. All communication between ActionDispatcher and model source is always through actions and is bi-directional. This is a powerful feature of Sprotty as it allows both flexibility regarding where and how the Diagram is generated, as well as changing or updating and reacting to interactions with the diagram simultaneously.\nThe following sections will explain how to use and work with the different types of model sources.\nGeneral usage Regardless of the model source we are using, the first thing we have to do is to register our model source in the front-end DI-container like this:\nbind(TYPES.ModelSource).to(ModelSourceClassOrProxy).inSingletonScope(); After that, we can retrieve the model source with the following code to further configure and use it.\nconst modelSource = container.get\u0026lt;LocalModelSource\u0026gt;(TYPES.ModelSource); Local Model Source A LocalModelSource instance allows us to set and modify the model through function calls, and keeps the model schema saved locally. To see how to use this model source, let\u0026rsquo;s have a look at the following example:\nimport {SNode} from \u0026#39;sprotty-protocol\u0026#39;; export default runExample() { const container = createContainer(\u0026#39;sprotty-showcase\u0026#39;); const modelSource = container.get\u0026lt;LocalModelSource\u0026gt;(TYPES.ModelSource); modelSource.setModel({ type: \u0026#39;graph\u0026#39; children: [ \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;main_node\u0026#39;, text: \u0026#39;node1\u0026#39;, position: {x: 0, y: 0} } ] }); document.getElementById(\u0026#39;addButton\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { modelSource.addElements([ { parentId: \u0026#39;graph\u0026#39;, element: \u0026lt;SNode\u0026gt;{ type: \u0026#39;node\u0026#39;, id: \u0026#39;new_node\u0026#39;, text: \u0026#39;new node\u0026#39;, position: {x: 100, y: 100} } }]) }) } In this example, we have a hard-coded data structure containing all the initial elements which are set in the model. Be aware that by defining the model this way we are defining the model schema - a data structure describing the model - and not the actual model itself. The model in this context means instances of the classes containing logic Sprotty uses for rendering. The model schema is used by Sprotty to generate the model. Due to this, we should use the interfaces for our nodes, edges, etc. from sprotty-protocol and not the classes from the sprotty main package. For disambiguation, model classes are suffixed with Impl in Sprotty, while interfaces (contained in the package sprotty-protocol) are not. This means that SNode is an interface, while SNodeImpl is a class.\nAfter defining the model schema we can then use methods like addElements() from our LocalModelSource to add new nodes at the click of a button. The LocalModelSource then handles updating the model and notifying the ActionDispatcher about the update, so that the view can receive an animated update.\nThrough methods like the ones outlined above, the LocalModelSource can also be used as a facade over the action-based API of Sprotty. It handles actions for bounds calculation and model updates.\nDiagram Server When the model needs to be generated from a remote source, like in a worker or from a server, we can use Sprotty\u0026rsquo;s DiagramServer model source. It communicates with the client through Action objects which can be serialized to plain JSON.\nOn the client-side, instead of registering an actual ModelSource we can use a DiagramServerProxy. The Proxy handles the communication and forwards actions to the ActionDispatcher. Out of the box, Sprotty offers the WebSocketDiagramServerProxy for communicating through WebSockets with the DiagramServer. Should a different form of communication be necessary we would have to create a custom proxy.\nUsing the WebSocketDiagramServerProxy is quite simple. We just need to call listen on the ModelSource and pass it the WebSocket we\u0026rsquo;re communicating with.\nconst modelSource = container.get\u0026lt;WebSocketDiagramServerProxy\u0026gt;(TYPES.ModelSource); modelSource.listen(websocket); For creating the DiagramServer itself, let\u0026rsquo;s look at an example.\n// Creating a new websocket server const wss = new WebSocketServer.Server({ port: 8080 }); // create our DiagramServices const elkFactory: ElkFactory = () =\u0026gt; new SocketElkServer(); const services: DiagramServices = { DiagramGenerator: new RandomGraphGenerator(), ModelLayoutEngine: new ElkLayoutEngine(elkFactory) } // Creating connection using websocket wss.on(\u0026#34;connection\u0026#34;, ws =\u0026gt; { const diagramServer = new DiagramServer(action =\u0026gt; { ws.send(JSON.stringify(action)); }, services) ws.on(\u0026#39;message\u0026#39; data =\u0026gt; { diagramServer.accept(data.action); }); }); In the example above, we assume we have a simple nodeJs WebSocket server and want to create a DiagramServer for it.\nAs we can see, there are two parts to creating the DiagramServer. First, we need a dispatch method to send actions from the server to the client. This can be as simple as calling ws.send() with the serialized action. Second, we need the DiagramServices. The DiagramServices type looks like this:\nexport interface DiagramServices { readonly DiagramGenerator: IDiagramGenerator readonly ModelLayoutEngine?: IModelLayoutEngine readonly ServerActionHandlerRegistry?: ServerActionHandlerRegistry } There are 3 components to the DiagramServices. One is mandatory, the other two are optional:\nThe DiagramGenerator which the server uses to create the schema of the Diagram Optionally the ModelLayoutEngine, like the ElkLayoutEngine from sprotty-elk, if we want to do server-side layouting Optionally the ServerActionHandlerRegistry for overwriting the default handling of incoming actions Creating a Custom Model Source Proxy In case communication between the DiagramServer and client does not work through WebSockets, for example when the DiagramServer is running in a worker or the sprotty client is in a vscode webview (see sprotty-vscode), we can easily implement our own proxy instead.\nexport class WebWorkerDiagramProxy extends DiagramServerProxy { constructor(private worker: Worker) { super() const proxy = this; worker.onmessage = function(event) { proxy.messageReceived(event.data) } } protected sendMessage(message: ActionMessage): void { this.worker.postMessage(JSON.stringify(message)); } } Following the example above, first we need to extend DiagramServerProxy. This already gives us most of our needed functionality and makes this proxy a ModelSource. Then we need to listen for incoming messages and pass them to the messageReceived() function, which deserializes and passes them to the ActionDispatcher. Lastly, we need to implement the sendMessage() method to allow actions coming from the ActionDispatcher to be transferred to the DiagramServer.\nNow our custom model source proxy is able to propagate all actions between the ActionDispatcher and our DiagramServer running in the worker, which gives us access to all of sprotty\u0026rsquo;s functionality.\n","description":"General usage Local Model Source Diagram Server Creating a Custom Model Source Proxy When drawing a diagram with Sprotty we need a place to define and update the schema of the diagram to draw. Sprotty uses model sources to do this. Sprotty currently offers two different model sources: The LocalModelSource for local models and the DiagramServer for remote ones. flowchart TD; ActionDispatcher ModelSource LocalModelSource DiagramServerProxy DiagramServer ActionDispatcher \u003c-.-\u003e|Action| ModelSource ModelSource --- LocalModelSource ModelSource --- DiagramServerProxy DiagramServerProxy \u003c-."},{"id":9,"href":"/docs/overview/","title":"Overview","parent":"Docs","content":" Action Dispatcher Action Model Source Command Stack Command SModel (SprottyModel) Viewer View Registry View The base architecture of Sprotty revolves around an unidirectional cyclic flow of information between three major components: the ActionDispatcher, the CommandStack, and the Viewer. This leads to a clear and easily testable flow of data which prevents feedback loops.\nflowchart TD; ActionDispatcher CommandStack Viewer ActionDispatcher --\u003e|Command| CommandStack CommandStack --\u003e|SModel| Viewer Viewer --\u003e|Action| ActionDispatcher Action Dispatcher The main role of the ActionDispatcher is to receive an Action and produce a corresponding command to be transmitted to the CommandStack using ActionHandlers. All operations on the diagram must be passed through the ActionDispatcher, so the CommandStack and the Viewer must never be invoked directly.\nThe ActionDispatcher also communicates with the ModelSource through Actions in a bidirectional manner, for example to inject external data into the loop or apply edits to the ModelSource.\nflowchart LR; ModelSource ActionDispatcher ModelSource --\u003e|Action| ActionDispatcher ActionDispatcher --\u003e|Action| ModelSource Action Actions are objects without behavior, JSON structures that describe what should happen but not how it should happen. As such, they can be serialized and serve as protocol messages that are exchanged between the client and the server. In actions, model elements are referred to by their IDs.\nModel Source There are two different ModelSources: the LocalModelSource offers an API to control the model directly in the client, while the DiagramServer delegates to a remote source, e.g. through a WebSocket or a VSCode extension.\nCommand Stack The CommandStack executes the commands it receives from the ActionDispatcher. It chains the promises returned by the execution methods and keeps an undo and a redo stack. It merges the current commands with the last one, e.g. to only keep the start and end point of a move from a drag operation. It is responsible for producing a graph model (namely SModel) and forwards it to the Viewer to be rendered.\nCommand Commands describe the behavior of their corresponding Action. They have the typical methods execute(), undo()and redo(), each of which take the current model and a command execution context as parameter, and return the new model or a promise for it. The latter serves to chain asynchronous commands such as animations.\nSModel (SprottyModel) The diagram is stored in an internal model called SModel. The root of the diagram is always an instance of SModelRootImpl and holds an index of the model to allow fast lookup of elements by ID. All elements of a diagram inherit SModelElementImpl which has a unique ID and a mandatory type referring to its View. The model elements are organized in a tree derived from the children and parent properties of each model element. It can be useful to introduce domain-specific information into the SModel. This can be achieved via creating new element classes that inherit from any related SModelElementImpl.\nflowchart BT; SModelElementImpl SShapeElementImpl SEdgeImpl SNodeImpl SPortImpl SLabelImpl CustomEdge CustomNode CustomPort CustomLabel SShapeElementImpl --\u003e SModelElementImpl SEdgeImpl --\u003e SModelElementImpl CustomEdge -.-\u003e SEdgeImpl SNodeImpl --\u003e SShapeElementImpl CustomNode -.-\u003e SNodeImpl SPortImpl --\u003e SShapeElementImpl CustomPort -.-\u003e SPortImpl SLabelImpl --\u003e SShapeElementImpl CustomLabel -.-\u003e SLabelImpl Viewer The Viewer is responsible for turning the internal model into its representation in the DOM. The conversion from an SModel to its representation in the DOM is not direct. Instead, Sprotty first creates a VirtualDOM and uses it to patch the actual DOM. This approach saves on expensive modification of the DOM by applying only the minimum amount of modification to it. The Viewer receives an SModel from the CommandStack and traverses it to apply a corresponding View to every element. The viewer is also responsible to add event listeners and animations using its Decorators. The received events should be converted to Actions and transferred to the ActionDispatcher.\nflowchart LR; Viewer ViewRegistry Views VirtualDOM DOM Viewer --\u003e ViewRegistry ViewRegistry --\u003e Views Views --\u003e|render| VirtualDOM VirtualDOM --\u003e|patch| DOM DOM --\u003e|event| Viewer View Registry The Viewer uses the ViewRegistry to look up the View for a graph model element using its ID.\nView A View knows how to turn a graph model element and its children into a virtual DOM node. It uses JSX technology and contains a render method producing one or a group of SVG elements.\n","description":"Action Dispatcher Action Model Source Command Stack Command SModel (SprottyModel) Viewer View Registry View The base architecture of Sprotty revolves around an unidirectional cyclic flow of information between three major components: the ActionDispatcher, the CommandStack, and the Viewer. This leads to a clear and easily testable flow of data which prevents feedback loops. flowchart TD; ActionDispatcher CommandStack Viewer ActionDispatcher --\u003e|Command| CommandStack CommandStack --\u003e|SModel| Viewer Viewer --\u003e|Action| ActionDispatcher Action Dispatcher The main role of the ActionDispatcher is to receive an Action and produce a corresponding command to be transmitted to the CommandStack using ActionHandlers."},{"id":10,"href":"/docs/smodel/","title":"SModel","parent":"Docs","content":" External Model Internal Model Elements Classes Inheritance SModelElementImpl SParentElementImpl SChildElementImpl SModelRootImpl ModelIndexImpl Graph Elements SGraphImpl SNodeImpl SPortImpl SEdgeImpl SLabelImpl SCompartmentImpl SGraphIndex ViewportRootElement SConnectableElementImpl SShapeElementImpl SRoutableElementImpl The SModel (short for SprottyModel) is the core data structure of Sprotty. It is a tree of model elements that can be rendered by a View. The root of the model is always an instance of SModelRootImpl or one of its derived class.\nFirst, we need to distinguish between two models: the internal model and the external model.\nThe internal model is used only in the CommandStack and the Viewer. It is a tree of model elements representing the current state of what is visible in the diagram. After a change has been applied via a Command. the CommandStack sends an updated version of the internal model to the Viewer which in turns renders the updated model using the provided View implementations.\nThe external model is used to transfer information between the model source and the Sprotty frontend. The external model must be serializable as JSON so that it can be easily transferred via network messages. Changes to the external model are applied through Actions, which contain the external model or parts of it. When the model source resides in the backend, the content of the diagram are controlled by a DiagramServer, which holds a copy of the external model.\nExternal Model The external model is tree of JSON-serializable objects. To facilitate its implementation, Sprotty provides a set of interfaces (in the sprotty-protocol package) that can be used to describe the external model. These interfaces have a class counterpart that is used in the internal model. The complete list of interfaces provided by Sprotty can be found here.\nInternal Model Elements The internal model is a tree of model elements implemented as classes. To avoid ambiguity with interfaces used in the external model, classes are named with the suffix Impl.\nClasses Inheritance flowchart BT; SModelElementImpl SParentElementImpl SChildElementImpl SModelRootImpl ModelIndexImpl SGraphImpl ViewportRootElement SNodeImpl SConnectableElementImpl SShapeElementImpl SPortImpl SEdgeImpl SRoutableElementImpl SLabelImpl SCompartmentImpl SGraphIndex SParentElementImpl --\u003e SModelElementImpl SChildElementImpl --\u003e SParentElementImpl SModelRootImpl --\u003e SParentElementImpl SGraphImpl --\u003e ViewportRootElement ViewportRootElement --\u003e SModelRootImpl SNodeImpl --\u003e SConnectableElementImpl SConnectableElementImpl --\u003e SShapeElementImpl SShapeElementImpl --\u003e SChildElementImpl SPortImpl --\u003e SConnectableElementImpl SEdgeImpl --\u003e SRoutableElementImpl SRoutableElementImpl --\u003e SChildElementImpl SLabelImpl --\u003e SShapeElementImpl SCompartmentImpl --\u003e SShapeElementImpl SGraphIndex --\u003e ModelIndexImpl SModelElementImpl This is the base class for all elements of the diagram model. This ensures that all elements in the model have a type and an id.\nProperties:\ntype: string: The type of the element. This value is used in the Sprotty configuration to specify the corresponding view for all elements of this type. id: string: The globally unique identifier of the element. features: FeatureSet - optional: A set of features that are enabled on the element. The list of features can be further configured in the dependency injection container. cssClasses: string[] - optional: A list of CSS classes that should be applied to the element. SParentElementImpl A parent element may contain children elements, thus the diagram model forms a tree.\nProperties:\nchildren: SChildElementImpl[]: The children of the element. Defaults to an empty array. Inheritance:\nSModelElementImpl\nSChildElementImpl A child element is contained in a parent element. All elements except for the model root are derived from SChildElementImpl. Every child element is also a parent element, thus it can contain children elements itself.\nProperties:\nparent: SParentElementImpl: The parent of the element. Inheritance:\nSParentElementImpl → SModelElementImpl\nSModelRootImpl This is the base class for the root element of the diagram model. It inherits from SParentElementImpl, therefore, actual model elements are contained in its children property.\nProperties:\ncanvasBounds: Bounds: The bounds of the canvas. This is used to determine the size of the diagram. Defaults to Bounds.EMPTY (i.e. {x: 0, y: 0, width: -1, height: -1}). revision: number- optional: The revision number of the model. This is incremented by Sprotty whenever the model is changed. This is used in the DiagramServer to ensure that the correct version of the model is used. Inheritance:\nSParentElementImpl → SModelElementImpl\nModelIndexImpl An index of all model elements. It is used to optimize the lookup of elements by their id.\nGraph Elements The base architecture of Sprotty does not assume that the visualization is based on nodes and edges. However, since it is a very common use-case, Sprotty provides a set of classes that can be used to build a graph-based diagram.\nSGraphImpl Root element of the diagram model.\nProperties:\nlayoutOptions: ModelLayoutOptions - optional: Options for the layout of the diagram. Inheritance:\nViewportRootModel → SModelRootImpl → SParentElement → SModelElementImpl\nSNodeImpl Model element for Nodes, which are the main entity in a graph. A node can be connected to another node via an edge. Such connection can be direct (i.e. the source or target of the edge is the node itself) or indirect (i.e. the source or target of the edge is a child port of the node).\nProperties:\nchildren: SChildElementImpl[] layout: string - optional selected: boolean: Indicates if the node is selected. Defaults to false. hoverFeedback: boolean: Indicates if the node should show hover feedback. Defaults to false. opacity: number: The opacity of the node. Defaults to 1. Inheritance:\nSConnectableElementImpl → SShapeElementImpl → SChildElementImpl → SParentElementImpl → SModelElementImpl\nDefault features:\nconnectableFeature deletableFeature selectFeature boundsFeature moveFeature layoutContainerFeature fadeFeature hoverFeedbackFeature popupFeature SPortImpl A port is a connection point for edges. It should always be contained in an SNodeImpl.\nProperties:\nselected: boolean: Indicates if the port is selected. Defaults to false. hoverFeedback: boolean: Indicates if the port should show hover feedback. Defaults to false. opacity: number: The opacity of the port. Defaults to 1. Inheritance:\nSConnectableElementImpl → SShapeElementImpl → SChildElementImpl → SParentElementImpl → SModelElementImpl\nDefault features:\nconnectableFeature selectFeature boundsFeature fadeFeature hoverFeedbackFeature SEdgeImpl These are the connectors for the diagram model. An edge has a source and a target. Each of which can either be a node or a port. The source and target elements are referenced by their id (inherited from SRoutableElementImpl) and can be resolved via the index stored in the root element.\nProperties;\nselected: boolean: Indicates if the edge is selected. Defaults to false. hoverFeedback: boolean: Indicates if the edge should show hover feedback. Defaults to false. opacity: number: The opacity of the edge. Defaults to 1. Inheritance:\nSRoutableElementImpl → SChildElementImpl → SParentElementImpl → SModelElementImpl\nDefault features:\neditFeature deletableFeature selectFeature fadeFeature hoverFeedbackFeature SLabelImpl A label represents some text to be displayed and attached to a node, compartment, port, or edge.\nProperties:\ntext: string: The text of the label. selected: boolean: Indicates if the label is selected. Defaults to false. alignment: Point: The alignment of the label. Defaults to Point.ORIGIN. opacity: number: The opacity of the label. Defaults to 1. edgePlacement: EdgePlacement - optional: The placement of the label on an edge. Defaults to EdgePlacement.NONE. rotate: boolean - true, if the label should be rotated to touch the edge tangentially side: EdgeSide - where is the label relative to the line\u0026rsquo;s direction. Possible values are \u0026lsquo;bottom\u0026rsquo;, \u0026rsquo;top\u0026rsquo;, \u0026rsquo;left\u0026rsquo;, \u0026lsquo;right\u0026rsquo;, and \u0026lsquo;on\u0026rsquo;. position: number - between 0 (source anchor) and 1 (target anchor) offset: number - space between label and edge/connected nodes moveMode: 'edge' | 'free' | 'none' - optional constrains where the label can be moved when move feature is enabled for the respective Label. edge means the label can be moved along the edge, free means the label can be moved freely, none means the label cannot moved. Defaults to edge. Inheritance:\nSShapeElementImpl → SChildElementImpl → SParentElementImpl → SModelElementImpl\nDefault features:\nboundsFeature alignFeature layoutableChildFeature edgeLayoutFeature fadeFeature SCompartmentImpl A compartment is used to group multiple child elements of a node or compartment, such as labels. Usually, a vbox or hbox layout is used to arrange these children.\nProperties:\nlayout: string - optional: The layout of the compartment. opacity: number: The opacity of the compartment. Defaults to 1. Inheritance:\nSShapeElementImpl → SChildElementImpl → SParentElementImpl → SModelElementImpl\nDefault features:\nboundsFeature layoutContainerFeature layoutableChildFeature fadeFeature SGraphIndex A specialized model index that tracks outgoing and incoming edges.\nInheritance:\nModelIndexImpl\nViewportRootElement Model root element that defines a viewport, so it transforms the coordinate system of its children with a scroll and zoom factor.\nProperties:\nscroll: Point: The scroll offset of the viewport. Defaults to {x: 0, y: 0}. zoom: number: The zoom factor of the viewport. Defaults to 1. position: Point: The position of the viewport. Defaults to {x: 0, y: 0}. size: Dimension: The size of the viewport. Defaults to {width: -1, height: -1}. Inheritance: SModelRootImpl → SParentElementImpl → SModelElementImpl\nSConnectableElementImpl A connectable element is one that can have outgoing and incoming edges. It can be the source or target element of an edge. There are two kinds of connectable elements: SNodes and SPorts.\nProperties:\nstrokeWidth: number: The stroke width of the element. Defaults to 0. Inheritance:\nSShapeElementImpl → SChildElementImpl → SParentElementImpl → SModelElementImpl\nSShapeElementImpl Abstract class for elements with a position and size.\nProperties:\nposition: Point: The position of the element. Defaults to {x: 0, y: 0}. size: Dimension: The size of the element. Defaults to {width: -1, height: -1}. layoutOptions: ModelLayoutOptions - optional: Options for the layout of the element. Inheritance:\nSChildElementImpl → SParentElementImpl → SModelElementImpl\nSRoutableElementImpl Abstract class for edges.\nProperties:\nrouterKind: string - optional: The kind of router to use for the edge. Sprotty provides an implementation of \u0026lsquo;polyline\u0026rsquo;, \u0026lsquo;manhattan\u0026rsquo;, and \u0026lsquo;bezier\u0026rsquo; routers. routingPoints: Point[] - optional: The routing points of the edge. Defaults to an empty array. sourceId: string: The id of the source element. targetId: string: The id of the target element. sourceAnchorCorrection: number - optional: The correction of the source anchor. This can be used to apply an offset to the anchor position of the source element. Defaults to 0. targetAnchorCorrection: number - optional: The correction of the target anchor. This can be used to apply an offset to the anchor position of the target element. Defaults to 0. To offset the anchor point of an edge\nInheritance:\nSChildElementImpl → SParentElementImpl → SModelElementImpl\n","description":"External Model Internal Model Elements Classes Inheritance SModelElementImpl SParentElementImpl SChildElementImpl SModelRootImpl ModelIndexImpl Graph Elements SGraphImpl SNodeImpl SPortImpl SEdgeImpl SLabelImpl SCompartmentImpl SGraphIndex ViewportRootElement SConnectableElementImpl SShapeElementImpl SRoutableElementImpl The SModel (short for SprottyModel) is the core data structure of Sprotty. It is a tree of model elements that can be rendered by a View. The root of the model is always an instance of SModelRootImpl or one of its derived class.\nFirst, we need to distinguish between two models: the internal model and the external model."},{"id":11,"href":"/","title":"Sprotty","parent":"","content":" Diagram Visualization Tools for Your Web Applications Eclipse Sprotty is an open source project enabling the creation of powerful diagramming tools and graphical visualizations. Fully customizable · Server and client-side diagramming · Easy integration · Powerful timesaver Get started Learn more\nSprotty provides a framework for rendering diagrams using the Scalable Vector Graphics (SVG) format, pluggable to powerful layout engines such as the Eclipse Layout Kernel (ELK). Sprotty is fully customizable , from the look of your diagram, down to its behavior. The example diagram shows part of a visual implementation of an electronic control unit used in the automotive domain (from ETAS EHANDBOOK). Try it live! Start exploring the diagram, hover over components, click on them, discover what Sprotty can do! Customizable and beautiful Sprotty makes it easy to create beautiful, interactive diagrams in web applications, with the ability to customize and integrate with external tools and services. From simple to advanced Sprotty provides a flexible and extensible framework that can be used for a wide range of diagramming needs, from simple flowcharts to advanced graphical editors that integrate with external services. Powerful timesaver With Sprotty, developers can save time and effort in creating powerful diagramming tools for their applications. At home in any kind of water... Sprotty can be used in any web application that supports web technologies such as HTML, CSS, and JavaScript. It is well suited for client-side diagramming, involving no server-side work whatsoever. It can also use server-side diagram generation for most complex use cases. Quick to hook... Sprotty can be integrated with various web frameworks such as React, Angular and Vue.js It can also be easily integrated into VSCode extensions. Many powerful graphical editors, such as Eclipse GLSP, are built on top of Sprotty! The following example shows a full integration between Sprotty and the Monaco Editor. The Monaco Editor runs a language server for a DSL created with Langium for creating state-machines. Edit the content of the editor and see changes transferred in real-time to the diagram!\nSprotty was first released in 2017 and has since been continuously developed and improved by a diverse community.\nFishing for professional support? Get help from the main contributors! The companies TypeFox and EclipseSource are specialized in custom development of diagram-based tools.\nStart using Eclipse Sprotty right now and become a part of the Sprotty school! About • Privacy Policy • Terms of Use • Copyright Agent © 2023 by Eclipse Foundation ","description":"Diagram Visualization Tools for Your Web Applications Eclipse Sprotty is an open source project enabling the creation of powerful diagramming tools and graphical visualizations. Fully customizable · Server and client-side diagramming · Easy integration · Powerful timesaver Get started Learn more\nSprotty provides a framework for rendering diagrams using the Scalable Vector Graphics (SVG) format, pluggable to powerful layout engines such as the Eclipse Layout Kernel (ELK). Sprotty is fully customizable , from the look of your diagram, down to its behavior."},{"id":12,"href":"/docs/dependency-injection/","title":"Sprotty configuration and dependency injection","parent":"Docs","content":" Why dependency injection? The container Features Creating custom components Dependency Injection specialties Multi bindings Provider Bindings As seen in the getting started guide, Sprotty relies heavily on dependency injection (DI) through InversifyJs for the configuration of its various components. This chapter will take a closer look at how to work with this.\nWhy dependency injection? DI allows us to:\nnot care about the instantiation and life-cycle of service components manage singletons like the various registries without using the global scope easily mock components in tests exchange default implementations with custom ones with minimum code changes modularize the configuration of specific features and scenarios and merge these modules for the final application The container The DI-container is the main point of configuration. The standard in Sprotty is to name this file di.config.ts.\nexport const createContainer = (containerId: string) =\u0026gt; { const myModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { bind(TYPES.ModelSource).to(LocalModelSource).inSingletonScope(); const context = { bind, unbind, isBound, rebind }; configureModelElement(context, \u0026#39;graph\u0026#39;, SGraphImpl, SGraphView); configureModelElement(context, \u0026#39;task\u0026#39;, SNodeImpl, TaskNodeView); configureModelElement(context, \u0026#39;edge\u0026#39;, SEdgeImpl, PolylineEdgeView); configureViewerOptions(context, { needsClientLayout: false, baseDiv: containerId }); }); const container = new Container(); loadDefaultModules(container); container.load(myModule, edgeIntersectionModule); return container; }; The container is built from multiple modules. Through loadDefaultModules() all modules are loaded for default Sprotty functionalities. We can also load other optional modules like the edgeIntersectionModule for extra functionality.\nMost important is our own module where the core of the configuration happens. Here we can configure singleton scope classes like our model source or rebind default Sprotty components (for example the logger) to a custom implementation. We use Symbols for bindings instead of using classes directly. All Symbols can be found in the TYPES object.\nUsing configureModelElement we can link our model to specific view components through the type property. Meaning if we have the following SNode, in our model, Sprotty will try to convert this data structure to an instance of the actual SNodeImpl class and render it with the TaskNodeView.\n\u0026lt;SNode \u0026amp; TaskNode\u0026gt;{ type: \u0026#39;task\u0026#39;, id: \u0026#39;task01\u0026#39;, name: \u0026#39;First Task\u0026#39;, isFinished: true, ... } Lastly, we need to configure our viewer options. Here we configure all the DOM elements needed by Sprotty, for example the base div inside of which our diagram is rendered, or the hidden div used by the first render cycle for determining micro layout. Another thing configured here is the layout. Specifically, if layout calculation should be done on client-side, server-side or both. This also determines the protocol spoken by the client and server.\nFeatures Model elements can further be configured through features.\nconfigureModelElement(context, \u0026#39;task\u0026#39;, SNodeImpl, TaskNodeView, { enable: [customFeature], disable: [moveFeature] }); the configureModelElement method takes an optional object as the last parameter containing arrays for enabled and disabled features, which in turn contain Symbols representing those features. Through this, we can disable default functionality like dragging or selecting nodes and add functionality, either custom or loaded from other non-default modules.\nCreating custom components As described previously Sprotty uses InversifyJs for dependency injection. That means when creating custom features, views, etc. we have to use this too. As an example, let\u0026rsquo;s look at Sprotty\u0026rsquo;s PolylineEdgeView.\n@injectable() export class PolylineEdgeView extends RoutableView { @inject(EdgeRouterRegistry) edgeRouterRegistry: EdgeRouterRegistry; ... } The most important thing for our component to be made available in Sprotty is annotating it with @injectable(). Otherwise the dependency injection won\u0026rsquo;t work.\nNow, as seen in the example above, we can just bind it in the container like this:\nconfigureModelElement(context, \u0026#39;edge\u0026#39;, SEdge, PolylineEdgeView); After that we can use all features of inversifyJs and inject other components registered in our container with @inject(...)\nFor more information on inversifyJs have a look to their documentation\nDependency Injection specialties Multi bindings Sometimes there is more than one implementation bound to a specific interface in Sprotty. This is when we use multi-bindings. Here is an example of the VNodeDecorator.\n@multiInject(TYPES.VNodePostprocessor)@optional() protected postprocessors: VNodePostprocessor[] Provider Bindings Sprotty\u0026rsquo;s circular event flow introduces a cyclic dependency between the components ActionDispatcher, CommandStack and Viewer. To handle these, we have to use provider bindings like this:\n// action-dispatcher.ts export type IActionDispatcherProvider = () =\u0026gt; Promise\u0026lt;IActionDispatcher\u0026gt;; // di.config.ts bind(TYPES.IActionDispatcher).to(ActionDispatcher).inSingletonScope(); bind(TYPES.IActionDispatcherProvider).toProvider\u0026lt;IActionDispatcher\u0026gt;(ctx =\u0026gt; { return () =\u0026gt; { return new Promise\u0026lt;IActionDispatcher\u0026gt;((resolve) =\u0026gt; { resolve(ctx.container.get\u0026lt;IActionDispatcher\u0026gt;(TYPES.IActionDispatcher)); }); }; }); ","description":"Why dependency injection? The container Features Creating custom components Dependency Injection specialties Multi bindings Provider Bindings As seen in the getting started guide, Sprotty relies heavily on dependency injection (DI) through InversifyJs for the configuration of its various components. This chapter will take a closer look at how to work with this.\nWhy dependency injection? DI allows us to:\nnot care about the instantiation and life-cycle of service components manage singletons like the various registries without using the global scope easily mock components in tests exchange default implementations with custom ones with minimum code changes modularize the configuration of specific features and scenarios and merge these modules for the final application The container The DI-container is the main point of configuration."},{"id":13,"href":"/docs/sprotty-elk/","title":"sprotty-elk","parent":"Docs","content":" Configuration Create a new Elk Factory Bind the ElkFactory to the ContainerModule Bind the ElkLayoutEngine to the ContainerModule Bind the LayoutConfigurator to the ContainerModule Load the ElkLayoutModule to the Container Process Transformation of an SModel to an ELK graph Preprocessing Layout Postprocessing Back to the SModel The sprotty-elk module provides a layout engine for Sprotty diagrams based on the Eclipse Layout Kernel (ELK).\nConfiguration In order to use ELK with Sprotty, several steps need to be done in order to inject the required components into the Sprotty container. If you are not already familiar with Sprotty\u0026rsquo;s dependency injection, you should first read the Sprotty documentation.\nA good example of how to use ELK with Sprotty can be found in the random graph example.\nCreate a new Elk Factory Outside of the ContainerModule, you need to create a new ElkFactory.\nimport { ElkFactory } from \u0026#39;sprotty-elk/lib/inversify\u0026#39;; import ElkConstructor from \u0026#39;elkjs/lib/elk.bundled.js\u0026#39;; export default (containerId: string) =\u0026gt; { ... const elkFactory: ElkFactory = () =\u0026gt; new ElkConstructor({ algorithms: [], // array of layout algorithms to be integrated into the layout engine defaultLayoutOptions: {}, // default layout options to be used by the layout engine workerUrl: \u0026#39;url\u0026#39; // URL to the ELK worker (elk-worker.js). If set, ELK will use a web worker to perform the layout computation }); } All parameters in the ElkConstructor are optional. The algorithms parameter is an array of layout algorithms to be integrated into the layout engine. By default layered, stress, mrtree, radial, force, and disco are available. If you want to use a different algorithm, you need to specify it in the algorithms parameter. Note that box, fixed, and random are always included.\nBind the ElkFactory to the ContainerModule The ElkFactory needs to be bound in the ContainerMoule.\nconst myModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { ... bind(ElkFactory).toFactory(elkFactory); }); Bind the ElkLayoutEngine to the ContainerModule const myModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { ... bind(TYPES.IModelLayoutEngine).toService(ElkLayoutEngine); }); Bind the LayoutConfigurator to the ContainerModule The LayoutConfigurator is used to apply layout options to the ELK graph. See the Layout section for more information.\nconst myModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { ... bind(MyLayoutConfigurator).toSelf().inSingletonScope(); rebind(ILayoutConfigurator).to(RandomGraphLayoutConfigurator).inSingletonScope(); }); Load the ElkLayoutModule to the Container const container = new Container(); loadDefaultModules(container); container.load(elkLayoutModule, myModule); return container; Process The Sprotty SModel is turned into an ELK graph. Optional preprocessing of the ELK graph. The ELK graph is laid out. Optional postprocessing of the ELK graph. Position and size information is transferred to the Sprotty SModel. Transformation of an SModel to an ELK graph In order to perform the layout, Elk requires a specific graph structure comprised of ElkNodes, ElkEdges, ElkPorts, and ElkLabels. On the other hand, the SModel can be comprised of an arbitrary number of nodes, edges, ports, and labels subtypes which are not directly compatible with the format that Elk supports.\nThe first thing we need to do is transform our SModel elements to ELK elements. This relies heavily on the basic_type:sub_type syntax. Only the basic type is considered when transforming SModel elements to their Elk counterpart. For example, an SModel node with the type node:my_type will be transformed into an ElkNode. Similarly, SModel elements of basic type edge will be transformed into an ElkEdge, label to ElkLabel, and port to ElkPort.\nThis transformation is done by the ElkLayoutEngine class, via the transformGraph method. The transformGraph method will traverse the SModel from its root (which is turned into an ElkNode instance) and transform its children into Elk elements. Every transformation of an SModel element is accompanied by the transformation of its children, if any.\nThe root element of the SModel must be of basic type graph.\nPreprocessing Once the SModel has been transformed into an ELK graph, we can apply some preprocessing to the graph. This is done by implementing a class implementing the ILayoutPreprocessor interface, and passing it to the constructor of the ElkLayoutEngine. The preprocessor class needs to implement a preprocess method, which will receive the ELK graph, the Sprotty graph, and the index.\nBy default, no preprocessing is done.\nFirst, we need to create a class implementing the ILayoutPreprocessor interface.\n@injectable() export class MyLayoutPreprocessor implements ILayoutPreprocessor { preprocess(elkGraph: ElkNode, sgraph: SGraph, index: SModelIndex): void { // apply preprocessing to the ELK graph } } Then, we need to bind the preprocessor to the ContainerModule.\nconst myModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { ... bind(ILayoutPreprocessor).to(Preprocessor).inSingletonScope(); }); Layout After preprocessing, the ELK graph is laid out. During that time, ELK will apply layout options to the respective ELK graph elements. By default, no options are applied.\nIn order to apply your own set of options to the layout engine, you need to implement a class extending the DefaultLayoutConfigurator.\nexport class MyLayoutConfigurator extends DefaultLayoutConfigurator { // options for the graph element protected override graphOptions(sgraph: SGraph, index: SModelIndex): LayoutOptions | undefined { return {\u0026#34;optionKey\u0026#34;: \u0026#34;optionValue\u0026#34;}; } // options for node elements protected override nodeOptions(snode: SNode, index: SModelIndex): LayoutOptions | undefined { return {\u0026#34;optionKey\u0026#34;: \u0026#34;optionValue\u0026#34;}; } // options for edge elements protected override edgeOptions(sedge: SEdge, index: SModelIndex): LayoutOptions | undefined { return {\u0026#34;optionKey\u0026#34;: \u0026#34;optionValue\u0026#34;}; } // options for label elements protected override labelOptions(slabel: SLabel, index: SModelIndex): LayoutOptions | undefined { return {\u0026#34;optionKey\u0026#34;: \u0026#34;optionValue\u0026#34;}; } // options for port elements protected override portOptions(sport: SPort, index: SModelIndex): LayoutOptions | undefined { return {\u0026#34;optionKey\u0026#34;: \u0026#34;optionValue\u0026#34;}; } } The complete list of available options can be found in the ELK documentation.\nPostprocessing Once the ELK graph has been laid out, we can apply some postprocessing to the graph. This is done by implementing a class implementing the ILayoutPostprocessor interface, and passing it to the constructor of the ElkLayoutEngine. The postprocessor class needs to implement a postprocess method, which will receive the ELK graph, the Sprotty graph, and the index. This postprecessor should be used to apply any changes to the ELK graph that are not possible to be done during the layout phase.\nBy default, no postprocessing is done.\nSimilarly to the preprocessor, we need to create a class implementing the ILayoutPostprocessor interface.\n@injectable() export class MyLayoutPostprocessor implements ILayoutPostprocessor { postprocess(elkGraph: ElkNode, sgraph: SGraph, index: SModelIndex): void { // apply postprocessing to the ELK graph } } Then, we need to bind the postprocessor to the ContainerModule.\nconst myModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { ... bind(ILayoutPostprocessor).to(Postprocessor).inSingletonScope(); }); Back to the SModel Once the ELK graph has been laid out and postprocessed, the position and size information is transferred back to the SModel.\n","description":"Configuration Create a new Elk Factory Bind the ElkFactory to the ContainerModule Bind the ElkLayoutEngine to the ContainerModule Bind the LayoutConfigurator to the ContainerModule Load the ElkLayoutModule to the Container Process Transformation of an SModel to an ELK graph Preprocessing Layout Postprocessing Back to the SModel The sprotty-elk module provides a layout engine for Sprotty diagrams based on the Eclipse Layout Kernel (ELK).\nConfiguration In order to use ELK with Sprotty, several steps need to be done in order to inject the required components into the Sprotty container."},{"id":14,"href":"/docs/styling/","title":"Styling","parent":"Docs","content":" Predefined Styling Available Views Default CSS Classes Using Subtypes for Styling Styling on a Per-Element Basis Styling from Custom Views Styling on User Interaction Sprotty is designed to be highly customizable. Styling of diagram elements is done using CSS, preferably using CSS classes. There are several ways to apply styles to an element depending on the level of granularity you need.\nPredefined Styling Available Views Sprotty comes with a handful of views that can be used to represent nodes, edges, and labels of your diagram. These views correspond to the most common SVG elements such as rect, circle, text, and path.\nThe following views can be used for visualizing nodes and ports:\nCircularNodeView: A circular representation of a node. Produces a circle SVG element. RectangularNodeView: A rectangular representation of a node. Produces a rect SVG element. DiamondNodeView: A diamond-shaped representation of a node. Produces a polygon SVG element. For representing edges, the following views are available:\nPolylineEdgeView: A succession of straight lines between two nodes. Produces a path SVG element. JumpingPolylineEdgeView: A succession of straight lines between two nodes with an arc where two or more edges intersect. Produces a path SVG element. PolylineEdgeViewWithGapsOnIntersections: A succession of straight lines between two nodes with a gap where two or more edges intersect. Produces a path SVG element. BezierCurveEdgeView: An succession of Bezier curves. Produces a path SVG element. For representing labels, the following view is available:\nSLabelView: A simple text label. Produces a text SVG element. Default CSS Classes Those default views assume that your are using the default implementations of diagram elements, namely SGraphImpl, SNodeImpl, SPortImpl, SEdgeImpl, and SLabelImpl.\nThe default views listed above use the following CSS classes to style the SVG elements:\nsprotty-graph: class for the root SVG element of the diagram. sprotty-node: class for the SVG element representing a node. sprotty-port: class for the SVG element representing a port. sprotty-edge: class for the SVG element representing an edge. sprotty-label: class for the SVG element representing a label. By using those CSS classes, you can easily style all nodes, ports, edges, and labels of your diagram in a uniform way.\nUsing Subtypes for Styling When dealing with diagrams with different types of nodes, ports, edges, or labels, it is common to want different styling for each type. Using the default CSS classes is not enough in this case as it would apply the same style to all nodes, ports, edges, or labels.\nBy convention, Sprotty uses the type property, which is a string of the shape main-type:sub-type, to distinguish between different types of diagram elements. For example, a node of type node:my-node has the main type node and the sub-type my-node.\nUsing this convention, you can add a CSS class for each diagram element sub-type. For example:\nA node of type node:my-node using the RectangularNodeView would have the following CSS classes: sprotty-node and my-node. A node of type node:my-other-node using the RectangularNodeView would have the following CSS classes: sprotty-node and my-other-node. This allows for more control over the styling of your diagram elements.\nStyling on a Per-Element Basis If the granularity of elements base type and sub-type is not enough for your use case, you can also style each diagram element individually. This can be done by adding a cssClasses property to the SModelElement that you want to style. This property should be an array of strings representing the CSS classes you want to apply to the element.\nconst myNode: SNode = { id: \u0026#39;node1\u0026#39;, type: \u0026#39;node:my-node\u0026#39;, cssClasses: [\u0026#39;special-node\u0026#39;, \u0026#39;some-other-css-class\u0026#39;] ... }; Assuming that this node is implementing the RectangularNodeView, the resulting SVG element would have the following CSS classes: sprotty-node, my-node, special-node, and some-other-css-class.\nStyling from Custom Views The highest level of control over the styling of your diagram elements is achieved by creating custom views. By creating a custom view, you can define the exact SVG elements that should be used to represent your diagram elements and apply any CSS classes you want.\nTo add a class to an SVG element, you need to use the class-my-class={boolean} convention inside of the SVG element. For example:\n\u0026lt;rect class-my-class={true}\u0026gt; Sprotty will internally convert this to the expected class attribute if the boolean is true.\nThis convention can be used to apply CSS classes to the SVG elements if a certain condition is met. For example, you could use this to apply a CSS class to an element if a certain property meets a condition:\nclass MyNodeImpl extends SNodeImpl { value: number; } class MyNodeView extends ShapeView { render(node: MyNodeImpl, context: RenderingContext, args?: ViewArgs): VNode | undefined { return \u0026lt;g\u0026gt; \u0026lt;rect x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34; width={node.size.width} height={node.size.height} class-sprotty-node={true} class-low-value={node.value \u0026lt; 10} class-high-value={node.value \u0026gt;= 10} /\u0026gt; {context.renderChildren(node)} \u0026lt;/g\u0026gt;; } } Styling on User Interaction Taking advantage of the conditional CSS classes, you can also apply styles to your diagram elements based on user interaction. For example, you could apply a CSS class to a node when it is selected. Without going into the details of how to handle user interaction, let\u0026rsquo;s look at how Sprotty\u0026rsquo;s default views handle this.\nSNodeImpl has the default feature selectFeature, meaning that when a node is selected, its selected property is set to true. This property can be used in the corresponding view to add a CSS class to the selected element. For example in the RectangularNodeView:\nexport class RectangularNodeView extends ShapeView { render(node: Readonly\u0026lt;SShapeElementImpl \u0026amp; Hoverable \u0026amp; Selectable\u0026gt;, context: RenderingContext, args?: IViewArgs): VNode | undefined { if (!this.isVisible(node, context)) { return undefined; } return \u0026lt;g\u0026gt; \u0026lt;rect class-sprotty-node={node instanceof SNodeImpl} class-sprotty-port={node instanceof SPortImpl} class-mouseover={node.hoverFeedback} class-selected={node.selected} x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34; width={Math.max(node.size.width, 0)} height={Math.max(node.size.height, 0)}\u0026gt;\u0026lt;/rect\u0026gt; {context.renderChildren(node)} \u0026lt;/g\u0026gt;; } } Note the class-selected={node.selected}. This will apply the CSS class selected to the SVG element when the selected property of the node is true.\nSimilarly, you can see that the class-mouseover={node.hoverFeedback} applies the CSS class mouseover to the SVG element when the hoverFeedback property of the node is true. For this the hoverFeedbackFeature must be enabled on the node.\n","description":"Predefined Styling Available Views Default CSS Classes Using Subtypes for Styling Styling on a Per-Element Basis Styling from Custom Views Styling on User Interaction Sprotty is designed to be highly customizable. Styling of diagram elements is done using CSS, preferably using CSS classes. There are several ways to apply styles to an element depending on the level of granularity you need.\nPredefined Styling Available Views Sprotty comes with a handful of views that can be used to represent nodes, edges, and labels of your diagram."},{"id":15,"href":"/docs/svg-rendering/","title":"SVG Rendering","parent":"Docs","content":" Virtual DOM Views Layouting Client Layout Server Layout Sprotty transforms a given SModel to its representation in the DOM in the form of a hierarchy of SVG elements. An SModel is composed of SModelElements, and each SModelElement has a type property that is associated to a single corresponding View. The ViewRegistry keeps a map of the correspondence between an element type and a view. These model elements are organized in the virtual DOM before being rendered as actual SVG elements in the DOM.\nVirtual DOM The virtual DOM is a tree-based, partial or complete representation of the DOM content. In our context, the virtual DOM contains a representation of our diagram SVG elements and their hierarchy. For every update made to the diagram, Sprotty generates a new SModel through the CommandStack and forwards it to the Viewer. Updates are often limited to a specific node or group of nodes and it would be unnecessarily expensive to have to re-render the entire diagram for each update. It is more efficient to apply minimal updates to directly impacted DOM elements. Sprotty relies on Snabbdom for handling elements in the virtual DOM and applying minimal changes the DOM through patching.\nViews Views are at the center of Sprotty\u0026rsquo;s rendering mechanism. They are classes implementing the IView interface and have a render() method that describes the SVG elements to be rendered for a given SModelElement type. Views use the TSX syntax, which allow combining HTML and TypeScript code to define elements, and therefore needs to reside inside of files with the .tsx extension.\nLet\u0026rsquo;s have a look at the definition of the NodeView from the Class Diagram example:\n@injectable() export class NodeView extends RectangularNodeView { override render(node: Readonly\u0026lt;SNodeImpl\u0026gt;, context: RenderingContext, args?: IViewArgs): VNode | undefined { if (!this.isVisible(node, context)) { return undefined; } return \u0026lt;g\u0026gt; \u0026lt;rect class-sprotty-node={true} class-node-package={node.type === \u0026#39;node:package\u0026#39;} class-node-class={node.type === \u0026#39;node:class\u0026#39;} class-mouseover={node.hoverFeedback} class-selected={node.selected} x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34; width={Math.max(node.size.width, 0)} height={Math.max(node.size.height, 0)}\u0026gt;\u0026lt;/rect\u0026gt; {context.renderChildren(node)} \u0026lt;/g\u0026gt;; } } The class NodeView extends RectangularNodeView which is a default View in Sprotty, ultimately implementing IView. Don\u0026rsquo;t forget to add the class decorator @injectable(), which is necessary for the Dependency Injection mechanism.\nThe render() method is the core of the View. It takes node \u0026ndash; that is the model element to be rendered - as an argument, a RenderingContext, and an optional args object. View implementations should first check whether the node should be rendered at all. This is an optimization step, as we only want to render SVG elements that are inside of the visible viewport and not hidden by some other user-defined filter. Eventually, the render() method returns a VNode which is Snabbdom\u0026rsquo;s virtual representation of a DOM element. This VNode can hold one and only one root element, therefore we need to group our SVG elements inside of a container element g. The SVG elements can be styled using CSS classes using Snabbdom\u0026rsquo;s notation. Classes are dynamically toggled with expressions of the form class-X={boolean expression}, with the class- prefix followed by the name of the class and a boolean expression to determine if the class should be toggled or not. In our example, the rect element created by the NodeView could have a class of sprotty-node, node-package, node-class, mouseover, selected, or any combination of those depending of the respective boolean expressions. It is then easy to style elements with CSS based on class names.\nOther attributes like width, height, and position are also defined here. Please note that the position is set at x=\u0026quot;0\u0026quot; y=\u0026quot;0\u0026quot; since the actual position will be determined by the layout engine later on.\nFinally, we render children of the node with the renderChildren() method from the RenderingContext. We strongly advocate for keeping the View\u0026rsquo;s responsibility to render only the SVG that is specific for the given node. Any child (e.g. labels, buttons, children nodes) should be rendered in their own View. This keeps the code better organized and removes the complexity of having to implement the layout of nested elements such as labels in the View itself and instead delegates this responsibility to the layout engine.\nLayouting It is important to distinguish two types of layout:\nThe client layout (or micro-layout) which deals with the layout of a node\u0026rsquo;s children. The server layout (or macro-layout) which deals with the overall shape of the diagram, placement of nodes and edges. Client Layout The client layout, a.k.a. micro-layout, occurs first. In this phase, Sprotty computes the position and size for elements that add some visual information such as labels to nodes and edges. Different layouts are selected using the layout property of a SNode or SCompartment. The values of the layout property can be:\nhbox for an horizontal layout. vbox for a vertical layout. stack for a stacking of children elements. The micro-layout is computed in two phases:\nA RequestBoundAction is received and the model is rendered invisibly (e.g. by assigning a width and height of zero to the elements). The locally used fonts and CSS styles are applied during this rendering phase. The resulting size information is used to invoke the selected layouts and the updated bounds are written into a ComputedBoundAction. The bounds stored in the ComputedBoundAction are applied to the model and initiates the visible rendering of the updated model with SetModelAction or UpdateModelAction. In depth documentation about the micro-layouting can be found here\nServer Layout The server layout, a.k.a. macro-layout takes place after the client layout. This is configured with an implementation of the ILayoutEngine interface. This takes care of the general shape of the diagram and computes the position of nodes and edges. Sprotty provides a package to use the Eclipse Layout Kernel(ELK), a JAVA-based automatic layout engine with several standard algorithms, but it is also of course possible to implement your own.\n","description":"Virtual DOM Views Layouting Client Layout Server Layout Sprotty transforms a given SModel to its representation in the DOM in the form of a hierarchy of SVG elements. An SModel is composed of SModelElements, and each SModelElement has a type property that is associated to a single corresponding View. The ViewRegistry keeps a map of the correspondence between an element type and a view. These model elements are organized in the virtual DOM before being rendered as actual SVG elements in the DOM."},{"id":16,"href":"/tags/","title":"Tags","parent":"Sprotty","content":"","description":""},{"id":17,"href":"/docs/user-interaction/","title":"User Interaction","parent":"Docs","content":" Interacting with a Sprotty Diagram Interacting with a Sprotty Diagram Sprotty offers multiple mouse and keyboard interactions by default listed in the following tables. The CTRL key in the following is equal to the CMD key on Mac.\nMouse left-click: toggle selection CTRL-click: add to/remove from selection left-click : drag move selection (when on selected element) left-click : drag pan viewport (when on diagram background) mouse wheel: zoom Touchpad click toggle selection drag move selection (when on selected element) two-finger pan up/down zoom zoom zoom Keys CTRL-SHIFT-A select all CTRL-SHIFT-C center selection, or if nothing is selected center the entire diagram CTRL-SHIFT-E export diagram to SVG CTRL-SHIFT-F zoom selection to fill the entire canvas, or if nothing is selected zoom the entire diagram CTRL-Z undo CTRL-SHIFT-Z redo ","description":" Interacting with a Sprotty Diagram Interacting with a Sprotty Diagram Sprotty offers multiple mouse and keyboard interactions by default listed in the following tables. The CTRL key in the following is equal to the CMD key on Mac.\nMouse left-click: toggle selection CTRL-click: add to/remove from selection left-click : drag move selection (when on selected element) left-click : drag pan viewport (when on diagram background) mouse wheel: zoom Touchpad click toggle selection drag move selection (when on selected element) two-finger pan up/down zoom zoom zoom Keys CTRL-SHIFT-A select all CTRL-SHIFT-C center selection, or if nothing is selected center the entire diagram CTRL-SHIFT-E export diagram to SVG CTRL-SHIFT-F zoom selection to fill the entire canvas, or if nothing is selected zoom the entire diagram CTRL-Z undo CTRL-SHIFT-Z redo "}]